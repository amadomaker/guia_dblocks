var MSG = {
  test: "TESTE",
  // Header
  home: "Início",
  bipes: "BIPES",
  amado_maker: "Amado Maker",
  dblocks: "Dblocks",
  ebook: "Ebook Dblocks na Prática",

  // Main Content
  introduction_to_dblocks: "Introdução ao Dblocks",
  in_this_section: "Nesta Seção",
  sections: "Seções",
  overview: "Visão Geral",
  what_is_dblocks: "O que é o Dblocks?",
  first_steps: "Primeiros Passos",
  exploring_platform: "Explorando a plataforma",
  resources_support: "Recursos e Suporte",


  // Subsections
  welcome_to_dblocks: "Bem-vindo ao Dblocks!",
  welcome_text:
    "Bem-vindo ao Dblocks! Este guia é sua porta de entrada para explorar o mundo da programação de sistemas embarcados e Internet das Coisas (IoT) de forma simples e criativa. Com uma interface baseada em blocos visuais (e a opção de usar código, se preferir), o Dblocks torna a tecnologia acessível para todos — de iniciantes curiosos a profissionais experientes.",
  what_you_will_learn: "O que você vai aprender?",
  intuitive_learning: "Aprendizado intuitivo",
  intuitive_learning_text:
    "O Dblocks utiliza blocos visuais para simplificar a programação, permitindo que você veja seus projetos ganharem vida com facilidade.",
  powerful_tools: "Ferramentas poderosas",
  powerful_tools_text:
    "A AmadoBoard, uma placa baseada no chip ESP32, será sua principal aliada, com funcionalidades como Wi-Fi, Bluetooth, sensores e atuadores embarcados.",
  practical_projects: "Projetos práticos",
  practical_projects_text:
    "Este guia está repleto de exercícios e exemplos que te ajudarão a aplicar o que aprendeu, desde acender LEDs até criar sistemas mais complexos.",
  creative_exploration: "Exploração criativa",
  creative_exploration_text:
    "Além dos fundamentos, você terá a chance de experimentar e criar projetos reais que refletem aplicações do mundo moderno.",

  what_is_dblocks_text1:
    "O Dblocks é uma plataforma que simplifica a programação de sistemas embarcados e IoT. Com uma interface de blocos visuais, você pode criar projetos sem se preocupar com detalhes técnicos complicados. Se preferir mais controle, também é possível programar em MicroPython.",
  what_is_dblocks_text2:
    "A plataforma é especialmente projetada para atender desde iniciantes, que desejam aprender os primeiros conceitos de programação, até profissionais que buscam desenvolver soluções rápidas e eficazes. Com o Dblocks, é possível explorar uma ampla gama de possibilidades, desde acionar LEDs até criar dashboards interativos para monitoramento remoto de sensores e dispositivos.",
  what_is_dblocks_text3:
    "O Dblocks foi inspirado no BIPES (Block-based Integrated Platform for Embedded Systems), uma plataforma open source amplamente reconhecida no Brasil e no exterior. Essa inspiração permitiu ao Dblocks evoluir, criando uma solução otimizada e direcionada para educação e desenvolvimento de IoT. Diferente do BIPES, o Dblocks foca no uso exclusivo da placa AmadoBoard, que é baseada no chip ESP32. Essa placa foi desenvolvida pela Amado Maker com o intuito de facilitar a criação de projetos, com diversos componentes embarcados e integra recursos avançados, como conectividade Wi-Fi e Bluetooth.",
  what_is_dblocks_text4:
    "A AmadoBoard não apenas é tecnicamente poderosa, mas também foi projetada pensando no aprendizado, facilitando o acesso de estudantes e entusiastas à programação e ao universo da IoT.",

  basic_requirements: "Requisitos Básicos",
  requirements_list: [
    "Placa AmadoBoard.",
    "Ter a biblioteca MicroPython instalada na placa.",
    "Cabo USB para conectar a placa ao computador.",
  ],
  quick_guide: "Guia Rápido",
  quick_guide_list: [
    "Conecte a placa: Use o cabo USB para ligar sua AmadoBoard ao computador.",
    "Abra o Dblocks: Acesse a plataforma pelo navegador.",
    "Crie seu primeiro projeto: Arraste os blocos para o workspace e clique em 'Executar'.",
  ],

  workspace: "Workspace",
  workspace_text:
    "O espaço de trabalho é o componente de nível mais alto. É aqui que você faz o trabalho de programação usando os blocos disponíveis, tendo opção de colocar, arrastar, excluir e estruturar conforme a sua necessidade.",
  toolbox: "Caixa de ferramentas",
  toolbox_text:
    "A caixa de ferramentas contém os blocos usados para programar. Os blocos podem ser arrastados para o espaço de trabalho. Há dois tipos principais de caixas de ferramentas: suspensas e de categoria.",
  category_toolbox: "Caixa de ferramentas da categoria",
  category_toolbox_text:
    "A caixa de ferramentas de categoria têm vários conjuntos de blocos, se você clicar em um item de categoria, ele abrirá um menu suspenso que exibe os blocos dessa categoria.",
  dropdown_toolbox: "Caixa de ferramentas de menu suspenso",
  dropdown_toolbox_text:
    "A caixa de ferramentas de menu suspenso contém um conjunto de blocos que estão disponíveis para uso, é nela que você escolhe os blocos que serão usados no workspace.",
  context_menu: "Menu de contexto",
  context_menu_text:
    "O menu de contexto aparece quando você clica com o botão direito do mouse. Ele exibe uma lista de ações que você pode realizar nesse elemento como duplicar um bloco, adicionar comentários e outras ações.",
  trash: "Lixeira",
  trash_text:
    "Na lixeira, você pode arrastar e soltar blocos para excluí-los. Também é possível clicar na lixeira para abrir um menu suspenso com os blocos excluídos para que você possa recuperá-los.",
  fields: "Campos",
  fields_text:
    "Um campo é um elemento visual que reside em um bloco. Ele pode ser editável (como uma entrada de texto) ou apenas informativo (como um rótulo).",
  icons: "Ícones",
  icons_text:
    "Um ícone é um elemento visual que reside em um bloco. Eles sempre estão no canto superior do bloco e geralmente criam bolhas.",
  action_bar: "Barra de ações",
  action_bar_text:
    "A barra de ações é uma parte fundamental para interagir com a AmadoBoard. É aqui onde você pode conectar a placa, executar programas, baixar o seu código para usar em qualquer outro momento e carregá-lo de volta quando quiser, além de outras funcionalidades.",

  need_help: "Precisa de ajuda?",
  resources_text: "Precisa de ajuda? Confira nossos recursos adicionais:",
  ebook_link: "Ebook Dblocks na Prática",
  complete_amadoboard_guide: "Guia Completo AmadoBoard",
  requirements_list_1: "Placa AmadoBoard.",
  requirements_list_2:
    "Ter a biblioteca <a href='https://joaodrj.github.io/Micropython_install/' target='_blank'>MicroPython</a> instalada na placa.",
  requirements_list_3: "Cabo USB para conectar a placa ao computador.",
  quick_guide_list_1:
    "<strong>Conecte a placa</strong>: Use o cabo USB para ligar sua AmadoBoard ao computador.",
  quick_guide_list_2:
    "<strong>Abra o Dblocks</strong>: Acesse a <a href='https://dblocks.com.br/ui/index.html?lang=pt-br' target='_blank'>plataforma</a> pelo navegador.",
  quick_guide_list_3:
    "<strong>Crie seu primeiro projeto</strong>: Arraste os blocos para o workspace e clique em 'Executar'.",
  //Cards index
  introduction_to_dblocks: "Introdução ao Dblocks",
  introduction_description:
    "Nesta seção, vamos explorar os conceitos fundamentais do Dblocks e conhecer sua plataforma. Aprenda como a programação em blocos pode facilitar o desenvolvimento de projetos interativos.",
  knowing_amado_board: "Conhecendo a Amado Board",
  amado_board_description:
    "Nesta seção, vamos conhecer a Amado Board e suas principais características.",
  preparing_environment: "Preparando o ambiente",
  environment_description:
    "Aprenda como instalar os drivers necessários e configurar a AmadoBoard com MicroPython para começar a desenvolver seus projetos.",
  var_loop_print: "Variáveis, loops e impressão",
  var_loop_print_description:
    "Nesta seção, vamos aprender como trabalhar com variáveis, estruturas de controle e imprimir dados na tela.",
  logic_and_math: "Lógica e matemática",
  logic_and_math_description:
    "Nesta seção, vamos aprender a utilizar operadores lógicos e matemáticos para criar programas mais complexos e interessantes.",
  digital_input_output: "Entrada e saída digital",
  digital_io_description:
    "Descubra como funcionam as entradas e saídas digitais no Dblocks, aprendendo a conectar sensores e atuadores para criar projetos interativos.",
  analog_input_output: "Entrada e saída analógica",
  analog_io_description:
    "Descubra como funcionam as entradas e saídas analógicas no Dblocks, aprendendo a ler sensores e controlar atuadores com precisão para criar projetos avançados.",
  sensors: "Sensores",
  sensors_description:
    "Aprenda como utilizar sensores no Dblocks, aprendendo a coletar dados do ambiente e integrá-los em seus projetos para criar soluções interativas e inteligentes.",
  actuators: "Atuadores",
  actuators_description:
    "Aprenda como funcionam os atuadores no Dblocks, aprendendo a controlá-los para criar projetos interativos e dinâmicos que respondem a diferentes estímulos.",
  music: "Música",
  music_description:
    "Aprenda a utilizar a funcionalidade de música no Dblocks para compor melodias, ajustar tempo e reproduzir sons em seus projetos.",
  display: "Display",
  display_description:
    "Aprenda a utilizar o display para exibir textos, variáveis e leituras de sensores.",
  resources_and_features: "Recursos e funcionalidades",
  resources_description:
    "Conheça os recursos e funcionalidades que o Dblocks oferece para evoluir seus projetos.",
  // Página "Conhecendo a AmadoBoard" - Título
  ab_knowing_amado_board: "Conhecendo a AmadoBoard",

  // Índice
  ab_introduction: "Introdução",
  ab_main_features: "Características Principais",
  ab_system_power: "Alimentação do Sistema",
  ab_analog_sensors: "Sensores Analógicos",
  ab_motor_driver: "Motor Driver",
  ab_servo_motors_connection: "Conexão para Servo Motores",
  ab_leds_and_buzzer: "LEDs e Buzzer",
  ab_io_connectors: "Conectores de Entrada/Saída",
  ab_extra_components: "Componentes Extras",

  // Introdução
  ab_introduction_text:
    "A AmadoBoard é uma placa de desenvolvimento criada para facilitar projetos educacionais e experimentos tecnológicos. Baseada no ESP32, ela foi projetada para ser simples, prática e acessível, atendendo tanto iniciantes quanto usuários mais experientes. Com diversos componentes integrados, elimina a necessidade de acessórios extras, tornando o aprendizado e o desenvolvimento mais fáceis e eficientes.",

  // Características Principais
  ab_feature_esp32: "Arquitetura ESP32",
  ab_feature_wifi: "Interface Wi-Fi",
  ab_feature_bluetooth: "Interface Bluetooth",
  ab_feature_power_options:
    "Duas possibilidades de alimentação: via porta microUSB ou entrada jack de 6 a 12VDC",
  ab_feature_power_led: "LED indicador de alimentação",
  ab_feature_usb_debug: "Porta MicroUSB para debug e programação",
  ab_feature_motor_controller: "Controlador para dois motores DC integrados",
  ab_feature_io_pins: "13 pinos de IO disponíveis em headers",
  ab_feature_special_headers:
    "Headers formatados para pinouts específicos (servomotores, display OLED, sensor de ultrassons, etc.)",
  ab_feature_spi: "Header para SPI",
  ab_feature_i2c: "Dois headers para I2C",
  ab_feature_leds: "3 LEDs integrados e diretamente ligados a portas de IO",
  ab_feature_buzzer:
    "Buzzer integrado e diretamente conectado a um porto de IO",
  ab_feature_temp_sensor: "Sensor de temperatura integrado",
  ab_feature_ldr: "LDR integrada",
  ab_feature_trimmer: "Trimmer resistivo integrado",

  // Alimentação do Sistema
  ab_power_intro: "O sistema pode ser alimentado de duas formas:",
  ab_power_usb: "Porta USB (J4)",
  ab_power_jack: "Jack de alimentação (J2) - 6V a 12V",
  ab_power_regulators: "Inclui reguladores de tensão para 5V e 3.3V.",

  // Sensores Analógicos
  ab_analog_sensors_text:
    "Esses dispositivos não estão conectados ao microcontrolador, mas a um conector. Para utilizá-los, conecte um cabo jumper a uma porta do microcontrolador.",
  ab_sensor_temp: "Sensor de temperatura integrado (LM35)",
  ab_sensor_ldr: "LDR integrado",
  ab_sensor_trimmer: "Trimmer resistivo integrado",

  // Motor Driver
  ab_motor_driver_intro:
    "Inclui um circuito (L293) para controlar dois motores DC. Pinos de controle:",
  ab_motor_a: "Motor A: D12, D13, D14",
  ab_motor_b: "Motor B: D25, D26, D27",
  ab_motor_driver_control:
    "Os pinos de entrada determinam a direção, e o pino EN controla a velocidade via PWM.",

  // Conexão para Servo Motores
  ab_servo_motors_intro: "Dois conectores para servo motores:",
  ab_servo_a: "Servo A: D15 (alimentação 3.3V ou 5V)",
  ab_servo_b: "Servo B: D16 (alimentação 3.3V ou 5V)",

  // LEDs e Buzzer
  ab_leds_and_buzzer_text:
    "- LED vermelho indica 3.3V. - 3 LEDs controláveis: - Vermelho: D32 - Verde: D33 - Azul: D2 - Buzzer: D4",

  // Conectores de Entrada/Saída
  ab_io_connectors_text:
    "- Entrada: D34, D35, D36, D39 (analógico ou digital). - Saída: D5, D15, D16, D17, D18, D19, D21, D22, D23 (ex.: LEDs, buzzer). - I2C para OLED Display. - Barramento SPI.",

  // Componentes Extras
  ab_extra_potentiometer:
    "Potenciômetro: ajusta resistência (ex.: luz, volume).",
  ab_extra_resistors: "Resistores (100Ω, 330Ω, 1KΩ, 10kΩ): limitam corrente.",
  ab_extra_power_supply: "Fonte 9V 1A Bivolt: para projetos Arduino.",
  ab_extra_sonar: "Módulo Sensor de Distância Sonar HC-SR04: mede distâncias.",
  ab_extra_line_follower: "Módulo Seguidor de Linha TCRT5000: detecta linhas.",
  ab_extra_buzzer: "Buzzer: emite som.",
  ab_extra_ldr_module: "Módulo LDR: mede intensidade de luz.",
  ab_extra_dht11: "Sensor de temperatura DHT11: mede temperatura e umidade.",
  ab_extra_leds: "LEDs: indicam estados.",
  ab_extra_servo: "Servo Motor: controle preciso de ângulos.",
  ab_extra_dc_motor: "Motor DC: movimento contínuo.",
  ab_extra_oled: 'Display OLED (0.96", 128x64, I2C): tela compacta.',
  ab_extra_components_text:
    "Esses componentes permitem explorar conceitos de eletrônica e programação, integrando teoria e prática.",


//Pagina "Preparando o ambiente"

preparing_environment: "Preparando o ambiente",
en_first_step: "Primeiros passos",
en_introduction_text: "Primeiro precisamos instalar um driver para o computador/notebook reconhecer a placa através da conexão por cabo microusb. Baixe o driver CP210x através do link abaixo:",
en_install_driver: "Instalar driver",
en_found_download: "Procure por download ou transferência e baixe a versão indicada abaixo:",
en_info_micropython: "Para programar a placa Amado board no dblocks precisamos instalar o micropython e vamos fazer issoatravés do link abaixo para facilitar a instalação.",
en_install_micropython: "Instalar micropython",
en_info_micropython_page: "<span style='color:red;'>Na página de instalação contém um vídeo tutorial ensinando todo o processo</span>, o site é bem simples e intuitivo, basta clicar em conectar, selecionar a porta USB conforme a imagem abaixo e instalar o Micropython, esse processo pode demorar uns 2 minutos ou mais.",
en_acessing_plataform_title: "Acessando a plataforma",
en_acessing_plataform_info1: "Na barra de pesquisa procure por dblocks e acesse o primeiro site ou acesse pelo link: dblocks.com.br",
en_acessing_plataform_info2: "Na pagina inicial clique no botão “comece a programar”, logo após aparecerá uma mensagem de boas vindas com algumas informações, se já tiver feito a instalação do micropython pode fechar a mensagem, a sua placa já está pronta para uso, caso contrario clique em “Instalador Micropython e faça o processo”.",
en_useful_information: "Informações úteis",
en_inf_toolbox: "Na parte esquerda contem a toolbox com os blocos disponíveis para usar",
en_inf_workspace: "O espaçõ central é chamado de workspace e é onde colocaremos os nossos blocos.",
en_info_steel_bar: "Na parte superior direita temos alguns botões como o de concectar a nossa placa e o de rodar a programação.",
en_info_extra: "**Obs: Também é possivel baixar e recarregar a programação para usar quando quiser ou em outro computador.",
en_first_project_title: "Primeiro projeto: Piscar um led infinitamente",
en_first_project_step1: "Primeiro clique em Controle, depois em Laços e clique sobre o bloco “repita enquanto”, posicione conforme a sua vontade.",
en_first_project_step2: "Logo após clique em váriaveis, Boleanas e selecione o bloco 'Verdadeiro'. Posicione o bloco encaixando no bloco anterior no bloco anterior conforme mostra a imagem abaixo:",
en_first_project_step3: "Neste momento já temos o nosso loop que é responsável pela execução repetidamente do nosso programa, nesse caso fazer com que o nosso led piscar de forma infinita.",
en_first_project_step4: "O próximo passo é usar os blocos responsáveis por acender e apagar o nosso led que podem ser encontrados na categoria Pinos entrada/saida. Procure pelo bloco 'ajustar pino de saida' e posicione dentro do loop. Teremos que adicionar o mesmo bloco duas vezes, um para acender e outro para apagar, no segundo bloco escolha a opção flaso em 'para'.",
en_first_project_step5: "Também usaremos uma pausa para que o led permaneça aceso e apagado por um intervalo de tempo, procure pelo bloco 'esperar' em controle, selecionando a categoria Temporização. Posicione os blocos conforme a imagem abaixo mostra.",
en_first_project_step6: "Agora que já montamos o programa, clique no botão de conectar na parte superior direito, selecione a porta(placa) conectada ao seu computador e clique em conectar.",
en_first_project_step7: "Feito isso verá o ícone dessa forma sinalizando que a Amado board já está conectada a plataforma",
en_first_project_step8: "Agora basta clicar no botão que executa o programa e verá o led embutido na placa piscando em intervalos de 1 segundo.",
en_first_project_step9: "Observações: É possível executar e pausar o programa quantas vezes quiser clicando no mesmo botão.",
en_first_project_step10: "Parabéns! Você acaba de criar o seu primeiro programa usando a Amado board na plataforma Dblocks.",

//Página inOutDigital
di_title: "Entrada e Saída Digital",
di_introduction_title: "Introdução",
di_intro1: 'Em sistemas eletrônicos e de automação, as <strong>entradas digitais</strong> são sinais que o dispositivo recebe do ambiente. Esses sinais representam estados binários — geralmente "ligado" ou "desligado" (1 ou 0). Exemplos comuns incluem botões, sensores de presença e interruptores.',
di_intro2: "Já as <strong>saídas digitais</strong> são os sinais que o dispositivo envia para atuar sobre o ambiente, também em forma binária. Com elas, é possível controlar LEDs, relés, motores e outros componentes que operam em dois estados (ligado/desligado).",
di_intro3: "Esses conceitos são fundamentais em projetos de automação, onde sensores informam o estado do ambiente e atuadores respondem de acordo com a lógica definida.",
di_intro4: "A seguir, vamos ver como utilizar entradas e saídas digitais na prática de forma simples e intuitiva.",


//Entrada digital
di_in_title: "Entrada Digital",
di_in1: "Um exemplo prático de entrada digital pode ser feito com a plataforma <strong>dBlocks</strong> e a <strong>Amado Board</strong>.",
di_in2:"Na imagem abaixo, temos um programa que realiza a leitura contínua de um pino digital da placa:",
di_in3: "O que este programa faz?",
di_in4: "<strong>Enquanto o programa estiver rodando</strong>, ele executa repetidamente as instruções dentro do bloco <code>repita enquanto verdadeiro</code>.",
di_in5: "Ele <strong>lê o estado lógico</strong> (0 ou 1) do pino <strong>D16 / SERVO B</strong> usando o comando <code>ler entrada digital</code>.",
di_in6: "O valor lido é <strong>armazenado na variável <code>x</code></strong>.",
di_in7: "Em seguida, o programa <strong>imprime no console</strong> uma mensagem como: <code>Valor de x: 1</code> ou <code>Valor de x: 0</code>.",
di_in8: "O programa então <strong>aguarda 500 milissegundos</strong> antes de repetir a leitura.",
di_in9: "Montagem no hardware",
di_in10: "Para testar esse código na prática, você pode utilizar um <strong>jumper</strong> conectado ao pino <code>D16</code> da Amado Board. Alterne esse jumper entre o <strong>GND</strong> (0V) e os <strong>3.3V</strong>, simulando assim um sinal digital:",
di_in11: "Quando o jumper está no <strong>GND</strong>, o valor lido será <code>0</code>.",
di_in12: "Quando o jumper está nos <strong>3.3V</strong>, o valor lido será <code>1</code>.",
di_in13: "Isso demonstra claramente o funcionamento de uma entrada digital, mostrando como a placa interpreta dois estados distintos e como isso pode ser visualizado no console.",
di_in14: "Visualização dos resultados no console",
di_in15: "A plataforma dBlocks possui um console que permite acompanhar, em tempo real, o resultado das leituras feitas pelos blocos. No exemplo a seguir, vemos o valor da variável <code>x</code> sendo impresso continuamente:",
di_in16: "À medida que o jumper é alternado entre o GND e os 3.3V, o valor de <code>x</code> muda entre <strong>0</strong> e <strong>1</strong>, e isso é refletido imediatamente no console. Essa é uma maneira eficiente e clara de testar e depurar a lógica do seu projeto.",

//Saida Digital
di_out_title: "Saída Digital",
di_out1: 'As saídas digitais permitem que a placa controle dispositivos externos, enviando sinais do tipo "ligado" ou "desligado". Um exemplo clássico é o controle de um LED.',
di_out2: "Abaixo temos um exemplo onde o LED azul conectado ao pino <code>D2</code> da <strong>Amado Board</strong> pisca continuamente:",
di_out3: "O que este programa faz?",
di_out4: "O bloco <code>repita enquanto verdadeiro</code> garante que o programa fique executando em loop.",
di_out5: "O pino <code>D2 / LED AZUL</code> é configurado como saída digital.",
di_out6: "Primeiro, o LED é ligado com o comando <code>ajustar pino de saída para verdadeiro</code>.",
di_out7: "O programa então aguarda <strong>500 milissegundos</strong>.",
di_out8: "Depois, o LED é desligado com o comando <code>ajustar pino de saída para falso</code>.",
di_out9: "Mais uma vez, o programa aguarda <strong>500 milissegundos</strong>.",
di_out10: "Isso faz com que o LED pisque continuamente com um intervalo de meio segundo entre acender e apagar. Esse tipo de controle é muito útil em sistemas de sinalização, notificações visuais ou testes simples de funcionamento de pinos.",


// Página inOutAnalog
an_introduction_title: "Introdução",
an_intro1: "Em projetos eletrônicos, as <strong>entradas e saídas analógicas</strong> permitem trabalhar com sinais que variam de forma contínua. Diferente dos sinais digitais que só têm dois estados (0 ou 1), os sinais analógicos podem representar uma faixa de valores, o que os torna ideais para medir grandezas como luminosidade, temperatura ou controlar intensidade de um LED.",
an_intro2: "Neste exemplo, vamos utilizar o sensor de luz <strong>LDR</strong>, que já está embutido na <strong>Amado Board</strong>, como entrada analógica. E para a saída, vamos ajustar o brilho do LED interno da placa utilizando um sinal PWM.",
an_intro3: "Esses recursos são úteis em projetos onde é necessário perceber variações do ambiente ou controlar dispositivos com mais precisão.",

// Entrada Analógica
an_in_title: "Entrada Analógica",
an_in1: "Vamos fazer a leitura do sensor de luz LDR da placa ligando um jumper do terminal do LDR até o pino <code>39</code>, que é uma entrada analógica.",
an_in2: "O programa a seguir lê continuamente o valor de luminosidade captado pelo sensor e armazena esse valor em uma variável:",
an_in3: "O que este programa faz?",
an_in4: "Dentro do bloco <code>repita enquanto verdadeiro</code>, ele executa repetidamente as instruções.",
an_in5: "O pino <code>39</code> é lido com o comando <code>ler entrada analógica</code>.",
an_in6: "O valor lido é armazenado na variável <code>valor_ldr</code>.",
an_in7: "Esse valor é impresso no console para acompanhamento em tempo real.",
an_in8: "Há uma pausa de <strong>500 milissegundos</strong> antes da próxima leitura.",
an_in9: "Visualização dos resultados",
an_in10: "A cada variação da luminosidade ambiente, o valor da variável <code>valor_ldr</code> também varia. Isso pode ser observado no console da plataforma:",
an_in11: "Quanto mais claro o ambiente, maior o valor lido. Em ambientes escuros, o valor diminui. Isso demonstra como o sinal analógico representa uma grandeza física de forma contínua.",

// Saída Analógica
an_out_title: "Saída Analógica",
an_out1: "Para controlar a intensidade de um LED, utilizamos a técnica chamada <strong>PWM (modulação por largura de pulso)</strong>. Na prática, ela permite simular um sinal analógico em um pino digital.",
an_out2: "Abaixo temos um exemplo utilizando o bloco PWM para controlar o LED azul embutido da <strong>Amado Board</strong> conectado ao pino <code>D2</code>:",
an_out3: "O que este programa faz?",
an_out4: "O bloco <code>PWM</code> é usado dentro de um laço de repetição contínuo <code>repita enquanto verdadeiro</code>.",
an_out5: "Ele define o <strong>pino D2 / LED AZUL</strong> como saída com sinal PWM.",
an_out6: "A <strong>frequência</strong> foi configurada como <code>100 Hz</code>, o que indica quantos ciclos por segundo o sinal será enviado.",
an_out7: "O <strong>ciclo de trabalho (duty cycle)</strong> foi ajustado para <code>512</code>, o que representa 50% de intensidade (em uma escala de 0 a 1023).",
an_out8: "Alterando o valor do ciclo de trabalho, você pode controlar o brilho do LED. Valores mais baixos tornam o LED mais fraco e valores mais altos aumentam a intensidade. A frequência também pode ser ajustada para testar como diferentes taxas de oscilação afetam a suavidade da luz.",
an_out9: "Essa abordagem é muito útil em projetos como dimmers, controle de velocidade de motores ou qualquer aplicação onde a saída precisa ser graduada em vez de apenas ligada ou desligada.",

// Página Variáveis, Loops e Impressão - Parte de Variáveis
var_section_title: "Variáveis",
var_intro1: "Em programação, <strong>variáveis</strong> são usadas para armazenar valores que podem mudar ao longo do tempo. Elas são essenciais para guardar informações, fazer cálculos, controlar sensores ou mesmo imprimir mensagens no console.",
var_intro2: "Para criar uma variável, vá até a categoria <strong>Variáveis</strong> no menu lateral e clique em <strong>Criar variável...</strong>. Escolha um nome claro e significativo, pois isso evita erros e torna o programa mais fácil de entender.",
var_intro3: "Após criada, sua variável aparecerá em <strong>Variáveis criadas</strong> e poderá ser usada nos blocos para definir, alterar ou acessar seu valor.",
var_intro4: "Existem diferentes tipos de variáveis disponíveis:",
var_type_bool: "<strong>Booleanas</strong>: representam verdadeiro ou falso. Úteis para verificações ou condições.",
var_type_num: "<strong>Numéricas</strong>: armazenam números inteiros, decimais ou aleatórios, comuns em leituras de sensores e cálculos.",
var_type_text: "<strong>Texto</strong>: armazenam frases ou palavras, ideais para mostrar mensagens ou nomes.",
var_type_list: "<strong>Listas</strong>: armazenam vários valores em uma mesma variável. Muito útil para organizar dados.",
var_use_robotics: "Na robótica, variáveis são muito utilizadas para armazenar leituras de sensores como temperatura, distância, luz, entre outros. Isso permite tomar decisões ou ajustar comportamentos com base nos dados do ambiente.",
var_examples_title: "Exemplos de tipos de variáveis",
var_list_title: "Variáveis de Lista",
var_text_title: "Variáveis de Texto",
var_num_title: "Variáveis Numéricas",
var_bool_title: "Variáveis Booleanas",
var_print_example_title: "Exemplo prático: usando variáveis e impressão",
var_print_example_desc: "No exemplo abaixo, criamos duas variáveis: uma de texto chamada <code>nome</code> e outra numérica chamada <code>valor</code>. Depois, usamos o bloco <strong>imprime</strong> que está localizado na categoria Funções --> Texto para mostrar os valores no console.",
var_print_console_desc: "O resultado aparece no console como mostra a imagem a seguir. Esse recurso é muito útil para acompanhar os valores de sensores durante a execução do programa.",
//Seção Print
print_section_title: 'Impressão com o bloco "imprime"',
print_intro1: "A função de <strong>impressão</strong> permite acompanhar os valores durante a execução do programa. Isso é muito útil para verificar se os dados dos sensores ou variáveis estão corretos.",
print_intro2: "Para usar, acesse a categoria <strong>Funções → Texto</strong> e selecione o bloco <code>imprime</code>. Ele pode ser usado para mostrar textos simples ou valores de variáveis.",
print_ex1: "Exemplo 1: imprimir uma mensagem fixa",
print_ex2: "Exemplo 2: imprimir o valor de uma variável",
print_ex3: "Exemplo 3: imprimir dentro de um laço (loop)",
print_console_output: "O resultado desse último exemplo pode ser visto no console da plataforma, mostrando a contagem de 1 até 10:",

//seção loop
loop_section_title: "Laços de repetição (Loops)",
loop_intro1: "Loops são estruturas que permitem executar um mesmo conjunto de comandos várias vezes. Eles são úteis para automatizar tarefas repetitivas, como contar, exibir mensagens, ou manipular listas.",
loop_intro2: "Na plataforma, os blocos de repetição estão disponíveis na categoria <strong>Controle</strong> e incluem diferentes tipos de laços com finalidades variadas.",

loop_repeat_times_title: "1. Repetição com número fixo",
loop_repeat_times_desc: "O bloco <code>repita X vezes</code> executa o conjunto de comandos um número específico de vezes. Ideal para contagens simples ou ações repetidas.",
loop_repeat_times_explanation: "Neste exemplo, usamos uma variável <code>contador</code> para contar até 5. A cada repetição, imprimimos o valor atual.",

loop_repeat_while_title: "2. Repetição enquanto uma condição for verdadeira",
loop_repeat_while_desc: "O bloco <code>repita enquanto</code> continua executando os comandos enquanto a condição definida for verdadeira.",
loop_repeat_while_explanation: "Neste exemplo, a variável <code>numero</code> é incrementada até chegar a 5. O loop para quando a condição <code>numero < 5</code> não for mais verdadeira.",

loop_count_title: "3. Repetição com contador personalizado",
loop_count_desc: "O bloco <code>contar com i de X até Y por Z</code> permite maior controle sobre a repetição, incluindo o valor inicial, final e o passo.",
loop_count_explanation: "Neste exemplo, imprimimos a tabuada do 2, multiplicando o valor de <code>i</code> a cada repetição.",

loop_for_each_title: "4. Repetição para cada item de uma lista",
loop_for_each_desc: "O bloco <code>para cada item na lista</code> percorre todos os elementos de uma lista. Ideal para processar ou exibir vários dados.",
loop_for_each_explanation: "Aqui temos uma lista de nomes. O loop imprime um nome por vez até que todos sejam exibidos.",

loop_break_title: "5. Encerrar laço com condição",
loop_break_desc: "O bloco <code>encerra o laço</code> permite interromper a execução do loop antes de ele completar todas as repetições.",
loop_break_explanation: "Neste exemplo, contamos de 1 até 10, mas encerramos o laço quando o contador atinge o valor 6.",
loop_forever_title: "2. Repita enquanto verdadeiro",
loop_forever_desc: "O bloco <code>repita enquanto verdadeiro</code> executa os comandos de forma contínua, sem parar. É muito usado em projetos de robótica, onde o programa precisa rodar constantemente enquanto o sistema estiver ligado.",
loop_forever_explanation: "Neste exemplo, a variável <code>contador</code> é incrementada a cada segundo, e seu valor é impresso no console repetidamente.",

var_loop_print_end: "Todos os resultados dos exemplos acima podem ser visto no console da plataforma.",

//Página Sensores
sensor_title: "Sensores",
sensor_section_title: "Sensores na Robótica",
sensor_intro1: "Sensores são componentes que permitem que os robôs e sistemas embarcados percebam o ambiente ao seu redor. Eles captam informações como temperatura, luminosidade, distância, umidade, entre outros, convertendo esses dados em sinais que podem ser processados.",
sensor_intro2: "Na plataforma, os blocos relacionados a sensores estão disponíveis na categoria <strong>Sensores</strong>.",

// Seção Sensor Infravermelho
sensor_ir_title: "Sensor Infravermelho (IR)",
sensor_ir_desc1: "O sensor infravermelho (IR) é um componente digital simples e muito utilizado na robótica, especialmente em projetos como carrinhos seguidores de linha. Ele detecta a presença ou ausência de objetos com base no reflexo da luz infravermelha, retornando valores digitais: <strong>1</strong> quando não há reflexão e <strong>0</strong> quando detecta um objeto próximo.",
sensor_ir_desc2: "Este sensor possui <strong>3 pinos</strong> (VCC, GND e Sinal) e pode ser facilmente conectado à <strong>Amado Board</strong> usando os pinos de entrada digital, como <code>D34</code>, <code>D35</code>, <code>D36</code> e <code>D39</code>. A placa já possui espaço apropriado para o encaixe direto, tornando a montagem rápida e prática.",
sensor_ir_desc3: "Além de carrinhos seguidores de linha, o sensor IR pode ser usado em sistemas de contagem, barreiras de segurança, presença de objetos e outras aplicações onde a detecção simples de obstáculos é necessária.",
sensor_ir_example_title: "Exemplo: leitura contínua do sensor IR",
sensor_ir_steps: "O que esse programa faz?",

//Sensor de temperatura e umidade
sensor_dht_title: "Sensor de Temperatura e Umidade DHT11/22",
sensor_dht_desc1: "O sensor DHT11/22 é utilizado para medir dois dados importantes do ambiente: <strong>temperatura</strong> e <strong>umidade relativa do ar</strong>. Ele é muito comum em projetos de automação, estações meteorológicas e controle ambiental.",
sensor_dht_desc2: "Para que o sensor funcione corretamente na <strong>Amado Board</strong>, ele deve estar conectado a um <strong>pino digital</strong>. Recomendamos usar os pinos D5, D15, D16, D17, D18, D19, D21, D22 ou D23. Neste exemplo, vamos utilizar o pino <code>D17</code>.",
sensor_dht_desc3: "Como funciona o exemplo acima?",
sensor_dht_step1: "Inicializamos o sensor DHT11/22 e indicamos o pino de conexão.",
sensor_dht_step2: "Entramos em um loop que repete continuamente enquanto o sistema estiver ligado.",
sensor_dht_step3: "A cada repetição, a leitura da <strong>temperatura</strong> e da <strong>umidade</strong> é atualizada e armazenada em variáveis.",
sensor_dht_step4: "Esses valores são exibidos no console usando o bloco <code>imprime</code>.",
sensor_dht_step5: "Uma pausa de 1 segundo entre as leituras é muito importante para garantir o bom funcionamento do sensor.",
//Sensor Ultrassônico
sensor_ultra_title: "Sensor de Distância Ultrassônico HCSR04",
sensor_ultra_desc1: "O sensor ultrassônico HCSR04 é utilizado para medir distâncias com precisão, usando ondas de som. Ele envia um sinal sonoro (trigger) e mede o tempo até que o eco (echo) retorne após bater em um objeto. Com base nesse tempo, calcula-se a distância.",
sensor_ultra_desc2: "Na <strong>Amado Board</strong>, já existe um espaço próprio para encaixar esse sensor diretamente nos pinos <code>D17</code> (trigger) e <code>D34</code> (echo), facilitando sua conexão e uso em projetos de robótica.",
sensor_ultra_desc3: "Como funciona o exemplo acima?",
sensor_ultra_step1: "Inicializamos o sensor especificando os pinos de trigger (D17) e echo (D34), além do tempo limite para a leitura.",
sensor_ultra_step2: "Usamos um <strong>loop contínuo</strong> para medir a distância constantemente.",
sensor_ultra_step3: "A cada repetição, armazenamos o valor da distância em uma variável.",
sensor_ultra_step4: "O valor é impresso no console para que possamos acompanhar a medição em tempo real.",
sensor_ultra_step5: "Adicionamos uma pausa de 500 milissegundos para evitar leituras muito rápidas e garantir a estabilidade do sensor.",
sensor_ultra_note: "Observação: as leituras podem sofrer oscilações, apresentando valores muito altos ou até mesmo -1. Para melhorar a confiabilidade, implemente um filtro simples que descarte leituras fora da faixa esperada.",

//Módulo RFID
sensor_rfid_title: "Leitor RFID RC522",
sensor_rfid_desc1: "O RFID (Identificação por Rádio Frequência) é uma tecnologia usada para identificar objetos ou pessoas através de cartões ou tags que emitem sinais. É muito utilizada em sistemas de acesso, controle de presença e rastreamento de ativos.",
sensor_rfid_desc2: "O módulo utilizado neste exemplo é o RC522, que funciona por meio de comunicação SPI. Ele lê o UID (código único) de cartões RFID e pode também acessar a memória interna do cartão para leitura e escrita de dados.",
sensor_rfid_desc3: "A ligação do módulo à Amado Board deve seguir corretamente os nomes dos pinos. Alguns nomes são iguais, outros mudam entre o módulo, o bloco e a placa. Veja a correspondência recomendada:",
sensor_rfid_map1: "3.3V → 3.3V",
sensor_rfid_map2: "GND → GND",
sensor_rfid_map3: "SCK (módulo) = SCK no bloco = D18 / CLK na placa",
sensor_rfid_map4: "MOSI = MOSI no bloco = D23 / MOSI na placa",
sensor_rfid_map5: "MISO = MISO no bloco = D19 / MISO na placa",
sensor_rfid_map6: "RST = RST no bloco = D22 / SCL na placa",
sensor_rfid_map7: "SDA (do módulo) deve ser conectado ao CS no bloco, recomendado usar D5 como na imagem.",
sensor_rfid_desc4: "Embora os pinos RST e CS possam ser conectados a outros pinos digitais (como D17, D21 ou D22), recomendamos seguir o exemplo para maior compatibilidade.",
rfid_libraries_desc: "Para que os blocos do leitor RFID RC522 funcionem corretamente, é necessário instalar a biblioteca <code>mfrc522</code>, que permite a comunicação e leitura de cartões RFID.",
rfid_verify_library: "Após clicar no botão <strong>“Instalar biblioteca”</strong>, você pode verificar a instalação pela mensagem no console: <code>Instalação da biblioteca mfrc522 concluída.</code>",
rfid_verify_file: "Também é possível confirmar a presença da biblioteca abrindo a aba <strong>Arquivos</strong>. Clique duas vezes no botão de atualizar e verifique se o arquivo <code>mfrc522.py</code> aparece listado na memória da placa.",
sensor_rfid_desc6: "Abaixo vemos um programa básico que faz a leitura de um cartão RFID e mostra os resultados no console.",
sensor_rfid_expl_title: "Como funciona o exemplo acima?",
sensor_rfid_step1: "Inicializamos o módulo informando todos os pinos de conexão SPI.",
sensor_rfid_step2: "Entramos em um loop contínuo que verifica constantemente se um cartão está presente.",
sensor_rfid_step3: "Se um cartão for detectado (status = 0), uma mensagem será exibida no console e o UID será lido e impresso.",
sensor_rfid_step4: "Mesmo quando não há cartão, as informações de status e tipo da tag são mostradas para facilitar o debug.",
sensor_rfid_step5: "Adicionamos um delay de 500 milissegundos para evitar repetições muito rápidas.",
sensor_rfid_console_desc: "Abaixo você pode ver como os resultados aparecem no console da plataforma, mostrando o status, tipo de tag e o UID quando um cartão é detectado.",



//Página actuators
// Seção Atuadores
actuator_section_title: "Atuadores",
actuator_introduction: "Atuadores na robótica",
actuator_intro1: "Atuadores são dispositivos que recebem comandos de um sistema e realizam uma ação física no mundo real. Eles transformam sinais elétricos em movimento, som, luz, calor ou outras formas de resposta.",
actuator_intro2: "Na robótica e na automação, os atuadores são essenciais para interagir com o ambiente, permitindo acender lâmpadas, acionar motores, abrir válvulas, tocar buzinas, entre outros.",
actuator_intro3: "Na plataforma, os blocos de atuadores estão disponíveis na categoria <strong>Saídas e Atuadores</strong>. Cada tipo de atuador terá seus próprios blocos com comandos específicos.",

//Seção Módulo Relé
relay_title: "Módulo Relé",
relay_desc1: "O relé é um componente que funciona como um interruptor controlado eletronicamente. Ele permite ligar ou desligar dispositivos de maior potência (como lâmpadas, ventiladores ou eletrodomésticos) usando um sinal digital da placa.",
relay_desc2: "No bloco do relé, você pode escolher o pino ao qual ele está conectado e o comando desejado: <strong>ligar</strong> ou <strong>desligar</strong>. É importante lembrar que o módulo relé deve ser alimentado corretamente (geralmente com 5V e GND), e que a carga conectada precisa estar isolada e bem conectada para segurança.\n\nImportante: muitos módulos relé são acionados com sinal 0 (nível lógico baixo). Ou seja, ao usar o comando 'desligar' no bloco, o relé será ativado (ligando o dispositivo). Já o comando 'ligar' no bloco desativa o relé (desligando o dispositivo).",
relay_example_title: "Exemplo: ligar uma lâmpada com atraso",
relay_example_desc: "No exemplo abaixo, usamos o bloco de relé para simular o controle de uma lâmpada. Ao iniciar o programa, o relé é ligado (simulando a lâmpada acendendo), e após 3 segundos ele é desligado. Esse tipo de controle pode ser usado em aplicações como temporizadores, simulação de presença ou automação residencial.",
relay_example_note: "Esse exemplo simples de temporizador também poderia ser usado dentro de uma <strong>condição</strong> (por exemplo, ao detectar um cartão RFID, presença, horário, etc.) para tomar decisões automáticas no programa.",

// Seção Servo motor
servo_title: "Servo Motor",

servo_desc1: "O servo motor é um atuador muito utilizado em projetos de robótica e automação. Ele permite posicionar um eixo em ângulos específicos, geralmente entre 0 e 180 graus. Isso é ideal para controlar portas, braços mecânicos, alavancas, eixos ou sistemas que precisam de movimentos precisos e controlados.",

servo_desc2: "Na plataforma, o controle do servo é feito em dois passos: primeiro usamos o bloco <strong>Iniciar servo motor</strong> para definir o pino de conexão e o nome do servo, e depois usamos o bloco <strong>Mover servo</strong> para indicar o ângulo desejado. É possível usar nomes personalizados (como servo1, servo2 etc.), permitindo o controle de múltiplos servos no mesmo projeto.",

servo_desc3: "A <strong>Amado Board</strong> possui um local específico para conectar servo motores: os pinos <strong>D15</strong> e <strong>D16</strong> estão identificados como <code>SERVO A</code> e <code>SERVO B</code>, respectivamente. Ao lado desses pinos, existe um conjunto de 3 pinos rotulados como <code>3.3V</code>, <code>VS</code> e <code>5V</code>. Para que o servo receba energia corretamente, é necessário <strong>fazer um jumper conectando o pino VS ao pino 5V</strong>. Isso garante que o pino de sinal tenha energia para movimentar o servo com estabilidade.",

servo_desc4: "Os servos costumam ter fios com cores padrão: <strong>marrom</strong> (GND), <strong>vermelho</strong> (VCC) e <strong>amarelo</strong> (sinal de dados). A placa já possui o espaço correto para encaixe direto desses três pinos, facilitando a instalação.",

servo_basic_title: "Exemplo 1: controle de posições fixas",
servo_basic_desc: "Este exemplo movimenta o servo para três posições fixas: 0°, 90° e 180°, com um pequeno intervalo entre os movimentos. É ideal para demonstrar o funcionamento básico do servo e como controlar ângulos diretamente.",
servo_basic_steps: "O que esse programa faz?",
servo_basic_step1: "Inicializa o servo no pino D15.",
servo_basic_step2: "Move o servo para o ângulo 0°, espera 1 segundo.",
servo_basic_step3: "Move para 90°, depois para 180°, com pausas entre cada posição.",
servo_basic_step4: "O ciclo se repete continuamente.",

servo_smooth_title: "Exemplo 2: movimento contínuo com laço",
servo_smooth_desc: "Neste exemplo usamos um <strong>laço for</strong> para movimentar suavemente o servo de 0° até 180° e voltar. Isso cria um movimento fluido e contínuo, útil para simulações de radar, varredura ou movimentos controlados em braço robótico.",
servo_smooth_steps: "O que esse programa faz?",
servo_smooth_step1: "Inicializa o servo e entra em um loop contínuo.",
servo_smooth_step2: "Usa um laço para mover de 0° a 180°, esperando 10 ms a cada passo.",
servo_smooth_step3: "Após uma pausa, repete o movimento de 180° a 0°.",

servo_ultra_title: "Exemplo 3: controle por sensor ultrassônico",
servo_ultra_desc: "Aqui combinamos o servo com um <strong>sensor ultrassônico</strong> para simular uma <strong>porta automática</strong> ou cancela de shopping. Se a distância for menor que 100mm, o servo abre a porta (ângulo 90°). Caso contrário, ela permanece fechada (ângulo 0°).",
servo_ultra_tip: "A comparação é feita com o bloco <code>se</code> que pode ser expandido com a opção <code>senão</code>, ativada pela engrenagem do bloco. A operação <code><</code> usada na condição está disponível na categoria <strong>Matemática → Lógica</strong>.",
servo_ultra_steps: "O que esse programa faz?",
servo_ultra_step1: "Inicializa o servo e o sensor ultrassônico.",
servo_ultra_step2: "Lê a distância continuamente (em milímetros).",
servo_ultra_step3: "Se a distância for menor que 100 mm, o servo se move para 90°.",
servo_ultra_step4: "Caso contrário, o servo volta para 0°.",
servo_ultra_step5: "A leitura é feita a cada 150 ms.",

// Seção Motor DC
motor_title: "Motor DC",
motor_desc1: "Os motores DC (corrente contínua) são muito utilizados em projetos de robótica para movimentar carrinhos, braços mecânicos, esteiras, entre outros. Eles permitem controle de rotação e sentido através de sinais digitais.",
motor_desc2: "Na plataforma, controlamos o motor DC usando três pinos: <strong>PWM</strong> para a potência (velocidade) e <strong>DIR1</strong> e <strong>DIR2</strong> para a direção. O bloco <code>Iniciar motor DC</code> permite selecionar os pinos e dar um <strong>nome personalizado</strong> ao motor, como motor1, motor2, etc. Isso permite controlar vários motores de forma independente.",
motor_desc3: "A <strong>Amado Board</strong> já possui um espaço físico apropriado com bornes de parafuso azuis nas laterais da placa, facilitando a ligação de até dois motores diretamente. Esses bornes estão conectados aos pinos PWM, DIR1 e DIR2 da placa.",
motor_desc4: "A velocidade do motor é controlada com valores entre <code>0</code> (desligado) e <code>1023</code> (máxima potência). A direção é definida com o bloco de direção: <code>1</code> para frente, <code>2</code> para trás, e <code>0</code> para parada. Também há o bloco <strong>Parar motor</strong> que pode ser usado para interromper o movimento a qualquer momento.",

motor_example_title: "Exemplo: motor alternando direção",
motor_example_desc: "O exemplo abaixo demonstra o uso básico do motor DC alternando sua direção. O motor gira para um lado por alguns segundos, para, depois gira para o outro lado.",
motor_example_steps: "O que esse programa faz?",
motor_example_step1: "Inicializa o motor usando pinos PWM, DIR1 e DIR2.",
motor_example_step2: "Define a potência máxima (1023) e gira o motor para frente (direção 1).",
motor_example_step3: "Após 2 segundos, para o motor, espera mais 2 segundos.",
motor_example_step4: "Gira o motor na direção oposta (direção 2), espera 2 segundos e para novamente.",
motor_example_step5: "O ciclo se repete continuamente.",
motor_extra_note: "Além de testes básicos, o controle de motores DC é essencial em projetos de robótica como robôs seguidores de linha ou robôs que desviam de obstáculos. Nestes casos, sensores determinam o comportamento dos motores, permitindo que o robô se mova de forma autônoma conforme o ambiente.",

//Seção buzzer
buzzer_title: "Campainha (Buzzer)",

buzzer_intro1: "A campainha, também conhecida como buzzer, é um atuador que emite sons simples ou melodias. Pode ser utilizada para alarmes, avisos sonoros, confirmações de eventos ou até mesmo para tocar músicas temáticas. A Amado Board já possui um buzzer integrado conectado ao pino D4, que pode ser usado diretamente.",

buzzer_libraries_title: "Instalação das bibliotecas",
buzzer_libraries_desc: "Para que os blocos de sons e músicas funcionem corretamente, é necessário instalar duas bibliotecas:",
buzzer_verify_library: "Após clicar no botão “Instalar biblioteca”, você pode verificar a instalação pela mensagem no console: Instalação da biblioteca rtttl concluída.",
buzzer_verify_file: "Também é possível confirmar a presença da biblioteca abrindo a aba Arquivos. Clique duas vezes no botão de atualizar e verifique se o arquivo rtttl.py e songs.py aparece listado na memória da placa.",

buzzer_block_freq_title: "1. Reproduzir som por frequência",
buzzer_block_freq_desc: "Este bloco permite gerar um som especificando uma frequência (em Hertz) e uma duração (em segundos). Por exemplo, 1000 Hz gera um som agudo. Se você usar 0 ou -1 como tempo, o som será contínuo até que outro comando seja executado.",

buzzer_block_note_title: "2. Reproduzir som por nota musical",
buzzer_block_note_desc: "Neste bloco, você pode escolher uma nota musical (como D3, B1 etc.) e definir por quantos segundos ela será reproduzida. Isso é ideal para criar melodias simples manualmente.",

buzzer_block_music_title: "3. Reproduzir música pronta",
buzzer_block_music_desc: "Com este bloco, você pode escolher músicas temáticas pré-definidas, como Super Mario, Star Wars ou Picaxe. Basta selecionar o nome da música na lista.",

buzzer_block_user_title: "Observação: músicas criadas pelo usuário",
buzzer_block_user_desc: "Existe ainda um bloco chamado “Reproduzir buzzer no pino com melodia”. Esse bloco será usado em uma seção própria dedicada à criação de músicas personalizadas, usando a aba Música da plataforma. Não abordaremos esse recurso aqui.",

//Página Display
display_section_title: "Display OLED SSD1306",
display_intro1: "O display OLED SSD1306 é uma tela de pequeno porte com comunicação I2C, muito utilizada em projetos de eletrônica e robótica para exibir informações como textos, valores de sensores ou mensagens do sistema.",
display_intro2: "Na plataforma, os blocos para controle do display estão localizados na categoria Telas. Antes de utilizá-lo, é necessário instalar a biblioteca ssd1306 clicando no bloco Instalar biblioteca: ssd1306.",
display_connection_info: "A Amado Board possui um espaço dedicado para conexão do display, identificado na própria placa com o nome OLED DISPLAY. Esse conector utiliza comunicação I2C, e os pinos correspondentes são: SDA no pino D21 e SCL no pino D22. Basta encaixar o módulo OLED no local correto e iniciar a comunicação com esses pinos no bloco de inicialização.",
display_blocks_info: "Para que o texto ou valor apareça corretamente na tela, é fundamental seguir a ordem correta dos blocos: 1) limpar o display, 2) escrever o conteúdo (mensagem ou número) e 3) atualizar o display. O bloco de atualização envia de fato o conteúdo para o display, sem ele nada será mostrado.",

display_example1_title: "Exemplo 1: Escrever texto fixo no display",
display_example1_desc: "Neste exemplo, mostramos como posicionar um texto estático na tela usando os blocos adequados. Esse é o primeiro passo para qualquer projeto com o display.",
display_example1_steps: "O que esse programa faz?",
display_example1_step1: "Inicializa o display com os pinos corretos (I2C: 1, SCL: 22, SDA: 21).",
display_example1_step2: "Limpa o display para garantir que não haja resíduos de texto anterior.",
display_example1_step3: "Escreve o texto \"Hello\" na posição desejada da tela.",
display_example1_step4: "Atualiza o display para que o texto apareça.",

display_example3_title: "Exemplo 2: Atualizar valor com loop",
display_example3_desc: "Este exemplo demonstra como criar um contador que é atualizado constantemente no display. Ideal para aprender a manipular variáveis visuais.",
display_example3_steps: "O que esse programa faz?",
display_example3_step1: "Inicializa o display.",
display_example3_step2: "Cria uma variável que aumenta de valor a cada segundo.",
display_example3_step3: "Limpa o display, exibe o valor da variável e atualiza a tela continuamente.",

display_example4_title: "Exemplo 3: Mostrar valor do sensor LDR",
display_example4_desc: "Aqui mostramos como integrar o display com sensores. Neste caso, exibimos o valor da luminosidade lido por um sensor LDR.",
display_example4_steps: "O que esse programa faz?",
display_example4_step1: "Inicializa o display e configura a leitura do sensor LDR.",
display_example4_step2: "Lê continuamente o valor de luminosidade ambiente.",
display_example4_step3: "Mostra o valor na tela, atualizando a cada 500 milissegundos.",

//Página Lógica e Matemática
logic_math_intro_title: "Lógica e Matemática",
logic_math_intro1: "Os blocos de lógica e matemática são fundamentais na programação. Eles permitem criar condições, realizar cálculos, comparar valores e tomar decisões. Estão presentes em praticamente todos os tipos de projeto — desde a leitura de sensores, até o controle de motores e execução de ações com base em regras.",
logic_math_intro2: "A categoria Matemática contém operações como soma, subtração, multiplicação, divisão, arredondamento, raiz quadrada, seno, mapeamento de valores, entre outros. Já a categoria Lógica oferece comparadores (como =, <, >), operadores lógicos (E, OU), e blocos de decisão como se, senão e senão se.",

logic_math_example1_title: "Exemplo 1: Verificar se um número fixo é maior que 10",
logic_math_example1_desc: "Neste exemplo usamos os blocos se e senão para verificar se um valor fixo é maior que 10. O bloco de decisão (se) permite executar comandos apenas quando uma condição é verdadeira. A comparação é feita com o operador matemático >.",
logic_math_example1_steps: "O que esse programa faz?",
logic_math_example1_step1: "Cria uma variável com o valor 15.",
logic_math_example1_step2: "Compara se o número é maior que 10.",
logic_math_example1_step3: "Se verdadeiro, imprime 'Maior que 10', caso contrário imprime 'Menor ou igual a 10'.",
logic_math_example1_console: "Os resultados do teste são exibidos no console da plataforma. Para visualizar, clique na aba Console no canto superior da tela após executar o programa.",

logic_math_example2_title: "Exemplo 2: Converter valor analógico em porcentagem",
logic_math_example2_desc: "Neste exemplo, pedimos ao usuário que digite um valor numérico no console para simular a leitura de um sensor. Em seguida, usamos o bloco mapear da categoria Matemática, que serve para converter um valor de um intervalo para outro. Esse bloco é muito útil em projetos de robótica para transformar leituras de sensores (como luminosidade, distância ou temperatura) em escalas mais compreensíveis, como porcentagens. Isso facilita a tomada de decisões ou a exibição de dados ao usuário.",
logic_math_example2_steps: "O que esse programa faz?",
logic_math_example2_step1: "Pede ao usuário um valor numérico para simular uma leitura analógica.",
logic_math_example2_step2: "Converte esse valor para uma porcentagem usando o bloco mapear.",
logic_math_example2_step3: "Imprime o valor convertido (em %) no console.",
logic_math_example2_console: "O número é digitado diretamente no console, localizado na parte superior da tela. O valor convertido será exibido em seguida para acompanhamento da conversão em tempo real.",

logic_math_example3_title: "Exemplo 3: Controle de ventilação com “E”, “OU” e senão",
logic_math_example3_desc: "Neste exemplo, simulamos a lógica de um sistema de ventilação inteligente que considera tanto a temperatura quanto a umidade do ambiente. Usamos operadores lógicos E e OU junto com blocos condicionais se e senão se para definir o comportamento do sistema com base nos valores.",
logic_math_example3_steps: "O que esse programa faz?",
logic_math_example3_step1: "Cria duas variáveis com valores fixos para temperatura e umidade.",
logic_math_example3_step2: "Se temperatura > 30 E umidade > 70, imprime \"Ativar ventilador e desumidificador\".",
logic_math_example3_step3: "Senão se temperatura > 30 OU umidade > 70, imprime \"Ativar apenas ventilador\".",
logic_math_example3_step4: "Senão, imprime \"Ambiente confortável\".",
logic_math_example3_console: "Os resultados das decisões são mostrados no console, permitindo acompanhar o comportamento lógico do programa.",
logic_math_example3_tip: "Você pode alterar os valores das variáveis de temperatura e umidade para observar como o comportamento do programa muda. Isso ajuda a entender melhor o uso de condições combinadas e operadores lógicos em situações reais.",

//Página música
music_section_title: "Música",
music_section_intro: "Nesta seção, vamos aprender a utilizar a aba Música da plataforma para compor melodias personalizadas de forma visual, por meio de um piano roll interativo. Essas melodias podem ser testadas e posteriormente utilizadas em blocos com o buzzer.",
music_features_intro: "A interface possui diversos controles úteis:",
music_editor_info: "O piano roll funciona da seguinte forma: as colunas representam o tempo, e as linhas representam notas musicais. Você pode selecionar uma nota por coluna. Se pular uma coluna, aquele instante de tempo será um silêncio.",

music_example1_title: "Exemplo: Criando a melodia \"Do-Re-Mi-Fa-Sol-La-Si\"",
music_example1_desc: "Vamos criar uma melodia simples usando as notas musicais básicas.",

music_example2_title: "Tocando a melodia com o buzzer",
music_example2_desc: "Após salvar a melodia, vá até a aba Blocos. Em Saídas e Atuadores → Campainha (Buzzer), você encontrará o bloco Reproduzir buzzer no pino. Ao selecionar a melodia criada, você poderá reproduzi-la usando o buzzer da placa.",

music_extra_info_title: "Dicas adicionais",
music_extra_info: "Se você clicar com o botão direito do mouse sobre o bloco de melodia, verá opções úteis como Excluir ou Exportar aquela melodia individualmente.",

music_example3_title: "Exemplo: Melodia “Parabéns pra Você”",
music_example3_desc: "Neste exemplo, criamos uma versão simples da melodia “Parabéns pra Você” usando o editor de música da plataforma. Esta é uma boa forma de praticar a composição, trabalhar com ritmos e testar a reprodução com o buzzer.",
music_example3_notes: "As notas utilizadas, na ordem, são: C4, C4, D4, C4, F4, E4 / C4, C4, D4, C4, G4, F4. Cada grupo representa uma frase musical, e você pode continuar criando as próximas partes da música da mesma forma.",
music_example3_bpm: "Note que o BPM foi ajustado para 130, o que torna a música um pouco mais acelerada. Você pode experimentar diferentes valores de BPM para adaptar a velocidade da melodia conforme sua preferência.",
music_example3_tips: "Este tipo de exercício ajuda a entender como o tempo e as pausas influenciam na execução da música. Também permite praticar a organização das notas no piano roll e explorar possibilidades criativas.",

music_section_intro_title: "Introdução",


// Página Recursos e Funcionalidades
resources_section_title: "Recursos e Funcionalidades",
resources_intro: "Nesta seção vamos apresentar alguns recursos extras da plataforma que podem facilitar o uso e organização dos seus projetos. Esses detalhes muitas vezes passam despercebidos, mas tornam a experiência com o ambiente ainda mais eficiente.",

resources_project_block_title: "Bloco de Dados do Projeto",
resources_project_block_desc: "Sempre que um novo projeto é criado, o bloco Dados do projeto aparece automaticamente. Ele é muito útil, pois permite preencher o nome do autor, o ID do projeto (caso esteja integrado com IoT) e uma descrição personalizada. Essa descrição é usada como nome do arquivo quando você exporta o projeto, facilitando sua identificação no computador.",
resources_project_block_info: "Você também pode encontrar esse bloco na categoria Funções → Bipes e inseri-lo manualmente no projeto, caso necessário.",

resources_mult_projects_title: "Trabalhar com múltiplos projetos",
resources_mult_projects_desc: "Na parte superior da plataforma há um botão de usuário (ícone de perfil). Ao clicar nele, um painel lateral se abre com as opções de gerenciamento de projetos.",
resources_mult_projects_usage: "É possível criar vários projetos clicando no botão + e alternar entre eles rapidamente. Essa funcionalidade é excelente para organizar diferentes tarefas, rascunhos ou versões de código.",
resources_mult_projects_lang_title: "Idioma da plataforma",
resources_mult_projects_lang: "Ainda nesse painel, você pode alterar o idioma da interface, escolhendo entre Português, Inglês ou Espanhol. Essa opção aparece na parte inferior do painel.",

resources_topbar_title: "Outros botões da barra superior",
resources_topbar_desc: "Além do gerenciamento de projetos, a barra superior conta com outros botões muito úteis:",
resources_topbar_item_python: "<strong>Python (ícone)</strong>: abre diretamente a página de instalação do MicroPython para sua placa.",
resources_topbar_item_download: "<strong>Download</strong>: baixa o código do projeto no formato <code>.xml</code>.",
resources_topbar_item_upload: "<strong>Upload</strong>: permite carregar um arquivo <code>.xml</code> salvo anteriormente.",
resources_topbar_item_connect: "<strong>Conectar</strong>: botão com símbolo USB para conexão da placa com a plataforma.",
resources_topbar_item_play: "<strong>Play</strong>: executa o programa carregado na placa.",

resources_save_title: "Salvar o programa na placa (main.py)",
resources_save_intro: "Uma das funcionalidades mais importantes da plataforma é a possibilidade de salvar o programa diretamente na memória da placa, permitindo que ele seja executado automaticamente sempre que a placa for ligada. Isso é feito ao salvar o código com o nome main.py.",
resources_save_context: "Para isso, é necessário utilizar a aba Arquivos, que funciona como um gerenciador de arquivos interno da placa. Esse recurso é um diferencial da plataforma, pois permite salvar, editar, apagar e executar arquivos diretamente da memória interna do dispositivo.",
resources_save_steps: "Siga os passos abaixo para salvar seu programa como 'main.py':",
resources_save_check: "Após salvar, De dois cliques no botão refresh para atualizar a lista de arquivos da placa. Você verá o novo arquivo main.py com o rótulo run at boot, indicando que esse será o programa executado automaticamente ao ligar a placa.",
resources_save_edit: "Além de salvar, é possível editar ou excluir arquivos diretamente por essa aba. Para excluir o main.py por exemplo, basta clicar no ícone da lixeira ao lado do nome do arquivo.",
resources_save_tip: "Observação importante",
resources_save_note: "Em alguns casos, o programa pode continuar rodando mesmo após clicar em Stop. Se isso acontecer, clique no ícone de desconectar, pressione o botão de reset na placa e conecte novamente. O ícone de play deve reaparecer e você poderá acessar a memória da placa normalmente.",
resources_save_note2: "Esse comportamento é comum quando você deseja apagar o <code>main.py</code> ou voltar ao uso normal com a plataforma. Sempre que finalizar um projeto e quiser utilizá-lo com uma fonte externa de energia, salve como <code>main.py</code>.",
resources_save_step1: "Certifique-se de que a <strong>placa esteja conectada</strong> e <strong>nenhum programa esteja em execução</strong> (o botão <code>Play</code> precisa estar visível).",
resources_save_step2: "Acesse a aba <strong>Arquivos</strong>.",
resources_save_step3: "Na seção \"Blocos para código\", clique em <code>code.bipes.py</code> para visualizar seu programa.",
resources_save_step4: "Altere o nome do arquivo clicando sobre <strong>code.bipes.py</strong> no topo do editor e renomeie para <code>main.py</code>.",
resources_save_step5: "Clique em <strong>Salvar uma cópia</strong>.",

resources_save_step1: "Certifique-se de que a <strong>placa esteja conectada</strong> e <strong>nenhum programa esteja em execução</strong> (o botão <code>Play</code> precisa estar visível).",
resources_save_step2: "Acesse a aba <strong>Arquivos</strong>.",
resources_save_step3: "Na seção \"Blocos para código\", clique em <code>code.bipes.py</code> para visualizar seu programa.",
resources_save_step4: "Altere o nome do arquivo clicando sobre <strong>code.bipes.py</strong> no topo do editor e renomeie para <code>main.py</code>.",
resources_save_step5: "Clique em <strong>Salvar uma cópia</strong>.",

}
