var MSG = {
  test: "PRUEBA",
  // Header
  home: "Inicio",
  amado_maker: "Amado Maker",
  dblocks: "Dblocks",
  ebook: "Ebook Dblocks en la Práctica",

  // Main Content
  introduction_to_dblocks: "Introducción a Dblocks",
  in_this_section: "secciones",
  sections: "Secciones",
  overview: "Visión General",
  what_is_dblocks: "¿Qué es Dblocks?",
  first_steps: "Primeros Pasos",
  exploring_platform: "Explorando la Plataforma",
  resources_support: "Recursos y Soporte",

  // Subsections
  welcome_to_dblocks: "¡Bienvenido a Dblocks!",
  welcome_text:
    "¡Bienvenido a Dblocks! Esta guía es tu puerta de entrada para explorar el mundo de la programación de sistemas embebidos y el Internet de las Cosas (IoT) de una manera simple y creativa. Con una interfaz basada en bloques visuales (y la opción de usar código si lo prefieres), Dblocks hace que la tecnología sea accesible para todos, desde principiantes curiosos hasta profesionales experimentados.",
  what_you_will_learn: "¿Qué vas a aprender?",
  intuitive_learning: "Aprendizaje Intuitivo",
  intuitive_learning_text:
    "Dblocks utiliza bloques visuales para simplificar la programación, permitiéndote ver cómo tus proyectos cobran vida con facilidad.",
  powerful_tools: "Herramientas Poderosas",
  powerful_tools_text:
    "La AmadoBoard, una placa basada en el chip ESP32, será tu principal aliada, con funcionalidades como Wi-Fi, Bluetooth, sensores y actuadores integrados.",
  practical_projects: "Proyectos Prácticos",
  practical_projects_text:
    "Esta guía está repleta de ejercicios y ejemplos que te ayudarán a aplicar lo que has aprendido, desde encender LEDs hasta crear sistemas más complejos.",
  creative_exploration: "Exploración Creativa",
  creative_exploration_text:
    "Más allá de los fundamentos, tendrás la oportunidad de experimentar y crear proyectos reales que reflejen aplicaciones del mundo moderno.",

  what_is_dblocks_text1:
    "Dblocks es una plataforma que simplifica la programación de sistemas embebidos e IoT. Con una interfaz de bloques visuales, puedes crear proyectos sin preocuparte por detalles técnicos complicados. Si prefieres más control, también puedes programar en MicroPython.",
  what_is_dblocks_text2:
    "La plataforma está especialmente diseñada para atender desde principiantes que desean aprender los primeros conceptos de programación hasta profesionales que buscan desarrollar soluciones rápidas y efectivas. Con Dblocks, es posible explorar una amplia gama de posibilidades, desde activar LEDs hasta crear paneles interactivos para monitoreo remoto de sensores y dispositivos.",
  what_is_dblocks_text3:
    "Dblocks se inspiró en BIPES (Block-based Integrated Platform for Embedded Systems), una plataforma de código abierto ampliamente reconocida en Brasil y en el extranjero. Esta inspiración permitió a Dblocks evolucionar, creando una solución optimizada y dirigida a la educación y el desarrollo de IoT. A diferencia de BIPES, Dblocks se enfoca exclusivamente en la placa AmadoBoard, basada en el chip ESP32. Esta placa fue desarrollada por Amado Maker con el objetivo de facilitar la creación de proyectos, integrando varios componentes y recursos avanzados como conectividad Wi-Fi y Bluetooth.",
  what_is_dblocks_text4:
    "La AmadoBoard no solo es técnicamente poderosa, sino que también fue diseñada pensando en el aprendizaje, facilitando el acceso de estudiantes y entusiastas a la programación y al universo del IoT.",

  basic_requirements: "Requisitos Básicos",
  requirements_list: [
    "Placa AmadoBoard.",
    "Tener la biblioteca MicroPython instalada en la placa.",
    "Cable USB para conectar la placa a la computadora.",
  ],
  quick_guide: "Guía Rápida",
  quick_guide_list: [
    "Conecta la placa: Usa el cable USB para conectar tu AmadoBoard a la computadora.",
    "Abre Dblocks: Accede a la plataforma a través del navegador.",
    "Crea tu primer proyecto: Arrastra los bloques al espacio de trabajo y haz clic en 'Ejecutar'.",
  ],

  workspace: "Espacio de Trabajo",
  workspace_text:
    "El espacio de trabajo es el componente de nivel superior. Aquí es donde realizas el trabajo de programación usando los bloques disponibles, con opciones para colocar, arrastrar, eliminar y estructurar según tus necesidades.",
  toolbox: "Caja de Herramientas",
  toolbox_text:
    "La caja de herramientas contiene los bloques utilizados para programar. Estos bloques se pueden arrastrar al espacio de trabajo. Hay dos tipos principales de cajas de herramientas: desplegables y de categoría.",
  category_toolbox: "Caja de Herramientas por Categoría",
  category_toolbox_text:
    "La caja de herramientas por categoría tiene varios conjuntos de bloques. Al hacer clic en un elemento de categoría, se abre un menú desplegable que muestra los bloques de esa categoría.",
  dropdown_toolbox: "Caja de Herramientas Desplegable",
  dropdown_toolbox_text:
    "La caja de herramientas desplegable contiene un conjunto de bloques disponibles para usar, donde eliges los bloques que se usarán en el espacio de trabajo.",
  context_menu: "Menú Contextual",
  context_menu_text:
    "El menú contextual aparece al hacer clic con el botón derecho del ratón. Muestra una lista de acciones que puedes realizar en ese elemento, como duplicar un bloque, agregar comentarios y otras acciones.",
  trash: "Papelera",
  trash_text:
    "En la papelera, puedes arrastrar y soltar bloques para eliminarlos. También puedes hacer clic en la papelera para abrir un menú desplegable con los bloques eliminados para recuperarlos.",
  fields: "Campos",
  fields_text:
    "Un campo es un elemento visual que reside en un bloque. Puede ser editable (como una entrada de texto) o solo informativo (como una etiqueta).",
  icons: "Íconos",
  icons_text:
    "Un ícono es un elemento visual que reside en un bloque. Siempre están en la esquina superior del bloque y generalmente crean burbujas.",
  action_bar: "Barra de Acciones",
  action_bar_text:
    "La barra de acciones es una parte fundamental para interactuar con la AmadoBoard. Aquí es donde puedes conectar la placa, ejecutar programas, descargar tu código para usarlo en cualquier otro momento y cargarlo de nuevo cuando quieras, además de otras funcionalidades.",

  need_help: "¿Necesitas ayuda?",
  resources_text: "¿Necesitas ayuda? Consulta nuestros recursos adicionales:",
  ebook_link: "Ebook Dblocks en la Práctica",
  complete_amadoboard_guide: "Guía Rápida AmadoBoard",
  requirements_list_1: "Placa AmadoBoard.",
  requirements_list_2:
    "Tener la biblioteca <a href='https://joaodrj.github.io/Micropython_install/' target='_blank'>MicroPython</a> instalada en la placa.",
  requirements_list_3: "Cable USB para conectar la placa a la computadora.",
  quick_guide_list_1:
    "<strong>Conecta la placa</strong>: Usa el cable USB para conectar tu AmadoBoard a la computadora.",
  quick_guide_list_2:
    "<strong>Abre Dblocks</strong>: Accede a la <a href='https://dblocks.com.br/ui/index.html?lang=pt-br' target='_blank'>plataforma</a> a través del navegador.",
  quick_guide_list_3:
    "<strong>Crea tu primer proyecto</strong>: Arrastra los bloques al espacio de trabajo y haz clic en 'Ejecutar'.",
  introduction_to_dblocks: "Introducción a Dblocks",
  introduction_description:
    "En esta sección, exploraremos los conceptos fundamentales de Dblocks y conoceremos su plataforma. Aprende cómo la programación basada en bloques puede facilitar el desarrollo de proyectos interactivos.",
  knowing_amado_board: "Conociendo la Amado Board",
  amado_board_description:
    "En esta sección, conoceremos la Amado Board y sus principales características.",
  preparing_environment: "Preparando el entorno",
  environment_description:
    "Aprende cómo instalar los controladores necesarios y configurar la AmadoBoard con MicroPython para comenzar a desarrollar tus proyectos.",
  var_loop_print: "Variables, bucles e impresión",
  var_loop_print_description:
    "En esta sección, aprenderemos a trabajar con variables, estructuras de control e imprimir datos en pantalla.",
  logic_and_math_description: "En esta sección, aprenderemos a utilizar operadores lógicos y matemáticos para crear programas más complejos e interesantes.",

  digital_input_output: "Entrada y salida digital",
  digital_io_description:
    "Descubre cómo funcionan las entradas y salidas digitales en Dblocks, aprendiendo a conectar sensores y actuadores para crear proyectos interactivos.",
  analog_input_output: "Entrada y salida analógica",
  analog_io_description:
    "Descubre cómo funcionan las entradas y salidas analógicas en Dblocks, aprendiendo a leer sensores y controlar actuadores con precisión para crear proyectos avanzados.",
  sensors: "Sensores",
  sensors_description:
    "Aprende cómo utilizar sensores en Dblocks, recolectando datos del entorno e integrándolos en tus proyectos para crear soluciones interactivas e inteligentes.",
  actuators: "Actuadores",
  actuators_description:
    "Aprende cómo funcionan los actuadores en Dblocks, controlándolos para crear proyectos interactivos y dinámicos que respondan a diferentes estímulos.",
  music: "Música",
  music_description:
    "Aprende a utilizar la funcionalidad de música en Dblocks para componer melodías, ajustar el tiempo y reproducir sonidos en tus proyectos.",
  display: "Pantalla",
  display_description:
    "Aprende a usar la pantalla para mostrar textos, variables y lecturas de sensores.",
  resources_and_features: "Recursos y funcionalidades",
  resources_description:
    "Conoce los recursos y funcionalidades que Dblocks ofrece para evolucionar tus proyectos.",
  ab_knowing_amado_board: "Conociendo la AmadoBoard",

  // Índice
  ab_introduction: "Introducción",
  ab_main_features: "Características Principales",
  ab_system_power: "Alimentación del Sistema",
  ab_analog_sensors: "Sensores Analógicos",
  ab_motor_driver: "Controlador de Motores",
  ab_servo_motors_connection: "Conexión para Servomotores",
  ab_leds_and_buzzer: "LEDs y Zumbador",
  ab_io_connectors: "Conectores de Entrada/Salida",
  ab_extra_components: "Componentes Extras",

  // Introdução
  ab_introduction_text:
    "La AmadoBoard es una placa de desarrollo creada para facilitar proyectos educativos y experimentos tecnológicos. Basada en el ESP32, fue diseñada para ser simple, práctica y accesible, atendiendo tanto a principiantes como a usuarios más experimentados. Con diversos componentes integrados, elimina la necesidad de accesorios adicionales, haciendo que el aprendizaje y el desarrollo sean más fáciles y eficientes.",

  // Características Principais
  ab_feature_esp32: "Arquitectura ESP32",
  ab_feature_wifi: "Interfaz Wi-Fi",
  ab_feature_bluetooth: "Interfaz Bluetooth",
  ab_feature_power_options:
    "Dos opciones de alimentación: vía puerto microUSB o entrada jack de 6 a 12VDC",
  ab_feature_power_led: "LED indicador de alimentación",
  ab_feature_usb_debug: "Puerto MicroUSB para depuración y programación",
  ab_feature_motor_controller: "Controlador para dos motores DC integrados",
  ab_feature_io_pins: "13 pines de IO disponibles en headers",
  ab_feature_special_headers:
    "Headers formateados para pinouts específicos (servomotores, pantalla OLED, sensor ultrasónico, etc.)",
  ab_feature_spi: "Header para SPI",
  ab_feature_i2c: "Dos headers para I2C",
  ab_feature_leds:
    "3 LEDs integrados y directamente conectados a puertos de IO",
  ab_feature_buzzer:
    "Zumbador integrado y directamente conectado a un puerto de IO",
  ab_feature_temp_sensor: "Sensor de temperatura integrado",
  ab_feature_ldr: "LDR integrada",
  ab_feature_trimmer: "Trimmer resistivo integrado",

  // Alimentación del Sistema
  ab_power_intro: "El sistema puede alimentarse de dos formas:",
  ab_power_usb: "Puerto USB (J4)",
  ab_power_jack: "Jack de alimentación (J2) - 6V a 12V",
  ab_power_regulators: "Incluye reguladores de voltaje para 5V y 3.3V.",

  // Sensores Analógicos
  ab_analog_sensors_text:
    "Estos dispositivos no están conectados al microcontrolador, sino a un conector. Para usarlos, conecta un cable jumper a un puerto del microcontrolador.",
  ab_sensor_temp: "Sensor de temperatura integrado (LM35)",
  ab_sensor_ldr: "LDR integrado",
  ab_sensor_trimmer: "Trimmer resistivo integrado",

  // Controlador de Motores
  ab_motor_driver_intro:
    "Incluye un circuito (L293) para controlar dos motores DC. Pines de control:",
  ab_motor_a: "Motor A: D12, D13, D14",
  ab_motor_b: "Motor B: D25, D26, D27",
  ab_motor_driver_control:
    "Los pines de entrada determinan la dirección, y el pin EN controla la velocidad vía PWM.",

  // Conexión para Servomotores
  ab_servo_motors_intro: "Dos conectores para servomotores:",
  ab_servo_a: "Servo A: D15 (alimentación 3.3V o 5V)",
  ab_servo_b: "Servo B: D16 (alimentación 3.3V o 5V)",

  // LEDs y Zumbador
  ab_leds_and_buzzer_text:
    "- LED rojo indica 3.3V. - 3 LEDs controlables: - Rojo: D32 - Verde: D33 - Azul: D2 - Zumbador: D4",

  // Conectores de Entrada/Salida
  ab_io_connectors_text:
    "- Entrada: D34, D35, D36, D39 (analógico o digital). - Salida: D5, D15, D16, D17, D18, D19, D21, D22, D23 (ej.: LEDs, zumbador). - I2C para pantalla OLED. - Bus SPI.",

  // Componentes Extras
  ab_extra_potentiometer:
    "Potenciómetro: ajusta resistencia (ej.: luz, volumen).",
  ab_extra_resistors: "Resistores (100Ω, 330Ω, 1KΩ, 10kΩ): limitan corriente.",
  ab_extra_power_supply: "Fuente 9V 1A Bivolt: para proyectos Arduino.",
  ab_extra_sonar: "Módulo Sensor de Distancia Sonar HC-SR04: mide distancias.",
  ab_extra_line_follower: "Módulo Seguidor de Línea TCRT5000: detecta líneas.",
  ab_extra_buzzer: "Zumbador: emite sonido.",
  ab_extra_ldr_module: "Módulo LDR: mide intensidad de luz.",
  ab_extra_dht11: "Sensor de temperatura DHT11: mide temperatura y humedad.",
  ab_extra_leds: "LEDs: indican estados.",
  ab_extra_servo: "Servomotor: control preciso de ángulos.",
  ab_extra_dc_motor: "Motor DC: movimiento continuo.",
  ab_extra_oled: 'Pantalla OLED (0.96", 128x64, I2C): pantalla compacta.',
  ab_extra_components_text:
    "Estos componentes permiten explorar conceptos de electrónica y programación, integrando teoría y práctica.",

  // Página "Preparando el entorno"

  preparing_environment: "Preparando el entorno",
  en_first_step: "Primeros pasos",
  en_introduction_text:
    "Primero necesitamos instalar un controlador para que la computadora/portátil reconozca la placa a través de la conexión por cable microUSB. Descarga el controlador CP210x desde el enlace a continuación:",
  en_install_driver: "Instalar controlador",
  en_found_download:
    "Busca la opción de descarga o transferencia y descarga la versión indicada a continuación:",
  en_info_micropython:
    "Para programar la placa Amado board en Dblocks necesitamos instalar MicroPython, y lo haremos mediante el enlace a continuación para facilitar la instalación.",
  en_install_micropython: "Instalar MicroPython",
  en_info_micropython_page:
    "<span style='color:red;'>En la página de instalación hay un video tutorial que enseña todo el proceso</span>. El sitio es muy simple e intuitivo: solo haz clic en conectar, selecciona el puerto USB como se muestra en la imagen de abajo e instala MicroPython. Este proceso puede tardar unos 2 minutos o más.",
  en_acessing_plataform_title: "Accediendo a la plataforma",
  en_acessing_plataform_info1:
    "En la barra de búsqueda escribe Dblocks y accede al primer sitio, o entra directamente en: dblocks.com.br",
  en_acessing_plataform_info2:
    "En la página principal haz clic en el botón “comienza a programar”. A continuación, aparecerá un mensaje de bienvenida con algunas informaciones. Si ya instalaste MicroPython puedes cerrar el mensaje, tu placa ya está lista para usar; de lo contrario, haz clic en “Instalador de MicroPython” y sigue el proceso.",
  en_useful_information: "Información útil",
  en_inf_toolbox:
    "En el lado izquierdo se encuentra la caja de herramientas con los bloques disponibles para usar",
  en_inf_workspace:
    "El área central se llama espacio de trabajo (workspace) y es donde colocaremos nuestros bloques.",
  en_info_steel_bar:
    "En la parte superior derecha hay algunos botones, como el de conectar la placa y el de ejecutar el programa.",
  en_info_extra:
    "**Nota: También es posible descargar y recargar el programa para usarlo cuando quieras o en otra computadora.",
  en_first_project_title: "Primer proyecto: Parpadear un LED infinitamente",
  en_first_project_step1:
    "Primero haz clic en Control, luego en Bucles y selecciona el bloque 'repetir mientras'. Colócalo donde desees.",
  en_first_project_step2:
    "Luego haz clic en Variables, Booleanas y selecciona el bloque 'Verdadero'. Encájalo dentro del bloque anterior como muestra la imagen abajo:",
  en_first_project_step3:
    "En este punto ya tenemos nuestro bucle, que es responsable por ejecutar repetidamente nuestro programa – en este caso, hacer que el LED parpadee infinitamente.",
  en_first_project_step4:
    "El siguiente paso es usar los bloques responsables de encender y apagar el LED, que se encuentran en la categoría Pines de entrada/salida. Busca el bloque 'ajustar pin de salida' y colócalo dentro del bucle. Deberás añadir este bloque dos veces: uno para encender y otro para apagar. En el segundo bloque selecciona la opción falso en 'a'.",
  en_first_project_step5:
    "También usaremos una pausa para que el LED permanezca encendido y apagado durante un intervalo de tiempo. Busca el bloque 'esperar' en Control, dentro de la categoría Temporización. Coloca los bloques como muestra la imagen abajo.",
  en_first_project_step6:
    "Ahora que ya montamos el programa, haz clic en el botón de conectar en la parte superior derecha, selecciona el puerto (placa) conectado a tu computadora y haz clic en conectar.",
  en_first_project_step7:
    "Una vez hecho, verás el ícono de esta forma indicando que la placa Amado está conectada a la plataforma.",
  en_first_project_step8:
    "Ahora solo haz clic en el botón de ejecutar el programa y verás el LED incorporado en la placa parpadeando en intervalos de 1 segundo.",
  en_first_project_step9:
    "Observaciones: Es posible ejecutar y pausar el programa cuantas veces quieras haciendo clic en el mismo botón.",
  en_first_project_step10:
    "¡Felicidades! Acabas de crear tu primer programa usando la placa Amado en la plataforma Dblocks.",

  //Página inOutDigital
  di_introduction_title: "Introducción",
  di_intro1:
    'En sistemas electrónicos y de automatización, las <strong>entradas digitales</strong> son señales que el dispositivo recibe del entorno. Estas señales representan estados binarios — generalmente "encendido" o "apagado" (1 o 0). Algunos ejemplos comunes son botones, sensores de presencia e interruptores.',
  di_intro2:
    "Las <strong>salidas digitales</strong>, por otro lado, son señales que el dispositivo envía para actuar sobre el entorno, también en forma binaria. Con ellas, es posible controlar LEDs, relés, motores y otros componentes que operan en dos estados (encendido/apagado).",
  di_intro3:
    "Estos conceptos son fundamentales en proyectos de automatización, donde los sensores informan el estado del entorno y los actuadores responden de acuerdo con la lógica definida.",
  di_intro4:
    "A continuación, veremos cómo utilizar entradas y salidas digitales en la práctica de forma sencilla e intuitiva.",

  //Pushbutton
  di_in17: "Ejemplo con botón (pushbutton)",
  di_in18: "Ahora veamos un ejemplo utilizando un botón pulsador conectado al pin D39 de la placa Amado. El objetivo es detectar cuándo se presiona o se suelta el botón.",
  di_in19: "En el circuito de arriba, un terminal del botón está conectado a GND a través de una resistencia (generalmente de 1kΩ o 10kΩ), otro al pin de 5V y el tercero al pin D39.",
  di_in20: "A continuación, el programa realiza la lectura del botón e imprime su estado en la consola:",
  di_in21: "El bloque 'leer entrada digital' lee el pin D39 sin activar pull-up, ya que el circuito utiliza una resistencia de pull-down física.",
  di_in22: "El valor leído se almacena en la variable valorBotao.",
  di_in23: "El programa imprime este valor en la consola cada 500 milisegundos.",
  di_in24: "Cuando el botón está suelto, el valor leído será 0 (porque el pin está conectado a tierra mediante la resistencia).",
  di_in25: "Cuando se presiona el botón, el valor leído será 1 (el pin se conecta a 5V).",
  di_in26: "Consejo: es posible invertir esta lógica cambiando la resistencia del GND al pin de 5V. En ese caso, el valor leído será 1 cuando esté suelto y 0 cuando esté presionado.",
  
  //Entrada digital
  di_in_title: "Entrada Digital",
  di_in1:
    "Un ejemplo práctico de entrada digital se puede realizar con la plataforma <strong>dBlocks</strong> y la <strong>Amado Board</strong>.",
  di_in2:
    "En la imagen a continuación, tenemos un programa que realiza la lectura continua de un pin digital de la placa:",
  di_in3: "¿Qué hace este programa?",
  di_in4:
    "<strong>Mientras el programa esté en ejecución</strong>, ejecuta repetidamente las instrucciones dentro del bloque <code>repetir mientras verdadero</code>.",
  di_in5:
    "Lee el <strong>estado lógico</strong> (0 o 1) del pin <strong>D16 / SERVO B</strong> usando el comando <code>leer entrada digital</code>.",
  di_in6:
    "El valor leído se <strong>almacena en la variable <code>x</code></strong>.",
  di_in7:
    "Luego, el programa <strong>imprime en la consola</strong> un mensaje como: <code>Valor de x: 1</code> o <code>Valor de x: 0</code>.",
  di_in8:
    "El programa <strong>espera 500 milisegundos</strong> antes de repetir la lectura.",
  di_in9: "Montaje del hardware",
  di_in10:
    "Para probar este código en la práctica, puedes utilizar un <strong>jumper</strong> conectado al pin <code>D16</code> de la Amado Board. Cambia este jumper entre <strong>GND</strong> (0V) y <strong>3.3V</strong>, simulando así una señal digital:",
  di_in11:
    "Cuando el jumper está en <strong>GND</strong>, el valor leído será <code>0</code>.",
  di_in12:
    "Cuando el jumper está en <strong>3.3V</strong>, el valor leído será <code>1</code>.",
  di_in13:
    "Esto demuestra claramente el funcionamiento de una entrada digital, mostrando cómo la placa interpreta dos estados distintos y cómo esto puede visualizarse en la consola.",
  di_in14: "Visualización de los resultados en la consola",
  di_in15:
    "La plataforma dBlocks cuenta con una consola que permite seguir, en tiempo real, el resultado de las lecturas realizadas por los bloques. En el siguiente ejemplo, vemos el valor de la variable <code>x</code> imprimiéndose continuamente:",
  di_in16:
    "A medida que el jumper se alterna entre GND y 3.3V, el valor de <code>x</code> cambia entre <strong>0</strong> y <strong>1</strong>, y esto se refleja inmediatamente en la consola. Esta es una forma eficiente y clara de probar y depurar la lógica de tu proyecto.",

  //Salida Digital
  di_out_title: "Salida Digital",
  di_out1:
    'Las salidas digitales permiten que la placa controle dispositivos externos enviando señales del tipo "encendido" o "apagado". Un ejemplo clásico es el control de un LED.',
  di_out2:
    "A continuación, tenemos un ejemplo donde el LED azul conectado al pin <code>D2</code> de la <strong>Amado Board</strong> parpadea continuamente:",
  di_out3: "¿Qué hace este programa?",
  di_out4:
    "El bloque <code>repetir mientras verdadero</code> garantiza que el programa se ejecute en bucle.",
  di_out5:
    "El pin <code>D2 / LED AZUL</code> se configura como salida digital.",
  di_out6:
    "Primero, el LED se enciende con el comando <code>ajustar pin de salida a verdadero</code>.",
  di_out7: "El programa espera <strong>500 milisegundos</strong>.",
  di_out8:
    "Luego, el LED se apaga con el comando <code>ajustar pin de salida a falso</code>.",
  di_out9: "Una vez más, el programa espera <strong>500 milisegundos</strong>.",
  di_out10:
    "Esto hace que el LED parpadee continuamente con un intervalo de medio segundo entre encenderse y apagarse. Este tipo de control es muy útil en sistemas de señalización, notificaciones visuales o pruebas simples del funcionamiento de los pines.",

  // Página inOutAnalog
  an_introduction_title: "Introducción",
  an_intro1:
    "En proyectos electrónicos, las <strong>entradas y salidas analógicas</strong> permiten trabajar con señales que varían de forma continua. A diferencia de las señales digitales, que solo tienen dos estados (0 o 1), las señales analógicas pueden representar un rango de valores, lo que las hace ideales para medir magnitudes como la luz, la temperatura o controlar la intensidad de un LED.",
  an_intro2:
    "En este ejemplo, utilizaremos el sensor de luz <strong>LDR</strong> que ya viene incorporado en la <strong>Amado Board</strong> como entrada analógica. Para la salida, ajustaremos el brillo del LED integrado usando una señal PWM.",
  an_intro3:
    "Estas funciones son útiles en proyectos que requieren detectar variaciones del entorno o controlar dispositivos con mayor precisión.",

  // Entrada Analógica
  an_in_title: "Entrada Analógica",
  an_in1:
    "Vamos a leer el sensor de luz LDR de la placa conectando un jumper desde el terminal del LDR hasta el pin <code>39</code>, que es una entrada analógica.",
  an_in2:
    "El siguiente programa lee continuamente el valor de luminosidad captado por el sensor y lo almacena en una variable:",
  an_in3: "¿Qué hace este programa?",
  an_in4:
    "Dentro del bloque <code>repetir mientras verdadero</code>, ejecuta repetidamente las instrucciones.",
  an_in5:
    "El pin <code>39</code> se lee con el comando <code>leer entrada analógica</code>.",
  an_in6: "El valor leído se almacena en la variable <code>valor_ldr</code>.",
  an_in7:
    "Este valor se imprime en la consola para su monitoreo en tiempo real.",
  an_in8:
    "Hay una pausa de <strong>500 milisegundos</strong> antes de la siguiente lectura.",
  an_in9: "Visualización de resultados",
  an_in10:
    "Con cada variación en la luz ambiente, también cambia el valor de la variable <code>valor_ldr</code>. Esto puede observarse en la consola de la plataforma:",
  an_in11:
    "Cuanto más claro esté el entorno, mayor será el valor leído. En ambientes oscuros, el valor disminuye. Esto demuestra cómo la señal analógica representa una magnitud física de forma continua.",

  // Salida Analógica
  an_out_title: "Salida Analógica",
  an_out1:
    "Para controlar la intensidad de un LED, utilizamos una técnica llamada <strong>PWM (modulación por ancho de pulso)</strong>. En la práctica, simula una señal analógica en un pin digital.",
  an_out2:
    "A continuación, vemos un ejemplo usando el bloque PWM para controlar el LED azul integrado de la <strong>Amado Board</strong> conectado al pin <code>D2</code>:",
  an_out3: "¿Qué hace este programa?",
  an_out4:
    "El bloque <code>PWM</code> se usa dentro de un bucle continuo <code>repetir mientras verdadero</code>.",
  an_out5:
    "Configura el <strong>pin D2 / LED AZUL</strong> como salida con señal PWM.",
  an_out6:
    "La <strong>frecuencia</strong> se configuró en <code>100 Hz</code>, lo que indica cuántos ciclos por segundo se envía la señal.",
  an_out7:
    "El <strong>ciclo de trabajo</strong> se estableció en <code>512</code>, lo que representa un 50% de intensidad (en una escala de 0 a 1023).",
  an_out8:
    "Cambiando el valor del ciclo de trabajo puedes controlar el brillo del LED. Valores bajos reducen el brillo y valores altos lo aumentan. También puedes modificar la frecuencia para observar cómo afectan las diferentes tasas a la suavidad de la luz.",
  an_out9:
    "Este enfoque es muy útil en proyectos como reguladores de luz, controladores de velocidad de motores o cualquier aplicación donde la salida necesite variar en lugar de solo encenderse o apagarse.",

  // Página Variables, Bucles e Impresión - Sección de Variables
  var_section_title: "Variables",
  var_intro1:
    "En programación, las <strong>variables</strong> se utilizan para almacenar valores que pueden cambiar con el tiempo. Son esenciales para guardar información, realizar cálculos, controlar sensores o incluso imprimir mensajes en la consola.",
  var_intro2:
    "Para crear una variable, ve a la categoría <strong>Variables</strong> en el menú lateral y haz clic en <strong>Crear variable...</strong>. Elige un nombre claro y significativo para evitar errores y facilitar la comprensión del programa.",
  var_intro3:
    "Una vez creada, tu variable aparecerá en <strong>Variables creadas</strong> y podrás usarla en bloques para definir, cambiar o acceder a su valor.",
  var_intro4: "Existen diferentes tipos de variables disponibles:",
  var_type_bool:
    "<strong>Booleanas</strong>: representan verdadero o falso. Útiles para verificaciones o condiciones.",
  var_type_num:
    "<strong>Numéricas</strong>: almacenan números enteros, decimales o aleatorios. Comunes en lecturas de sensores y cálculos.",
  var_type_text:
    "<strong>Texto</strong>: almacenan frases o palabras. Ideales para mostrar mensajes o nombres.",
  var_type_list:
    "<strong>Listas</strong>: almacenan múltiples valores en una sola variable. Muy útiles para organizar datos.",
  var_use_robotics:
    "En robótica, las variables se usan ampliamente para almacenar lecturas de sensores como temperatura, distancia, luz, entre otros. Esto permite tomar decisiones o ajustar comportamientos según los datos del entorno.",
  var_examples_title: "Ejemplos de tipos de variables",
  var_list_title: "Variables de Lista",
  var_text_title: "Variables de Texto",
  var_num_title: "Variables Numéricas",
  var_bool_title: "Variables Booleanas",
  var_print_example_title: "Ejemplo práctico: uso de variables e impresión",
  var_print_example_desc:
    "En el siguiente ejemplo, creamos dos variables: una de texto llamada <code>nombre</code> y otra numérica llamada <code>valor</code>. Luego usamos el bloque <strong>imprime</strong> (en Funciones → Texto) para mostrar sus valores en la consola.",
  var_print_console_desc:
    "El resultado aparece en la consola como muestra la imagen. Esta función es muy útil para observar valores durante la ejecución del programa.",

  // Sección de Impresión
  print_section_title: 'Impresión con el bloque "imprime"',
  print_intro1:
    "La función de <strong>impresión</strong> permite monitorear los valores durante la ejecución del programa. Esto es útil para verificar si los datos de sensores o variables son correctos.",
  print_intro2:
    "Para usarla, ve a la categoría <strong>Funciones → Texto</strong> y selecciona el bloque <code>imprime</code>. Puede usarse para mostrar texto fijo o valores de variables.",
  print_ex1: "Ejemplo 1: imprimir un mensaje fijo",
  print_ex2: "Ejemplo 2: imprimir el valor de una variable",
  print_ex3: "Ejemplo 3: imprimir dentro de un bucle",
  print_ex1_desc: "Este es el ejemplo más simple del uso del bloque imprime. Solo muestra un texto fijo en la consola, como un mensaje o saludo.",
  print_ex2_desc: "Aquí definimos una variable llamada valor con el número 10 y usamos el bloque imprime para mostrar ese valor junto con un texto explicativo. Esto es útil para saber qué valor ha almacenado la variable.",
  print_ex3_desc: "En este ejemplo, usamos un bucle repite para contar del 1 al 10. En cada repetición, el valor de la variable se incrementa y se imprime en la consola. También hay una pausa de 1 segundo entre impresiones para facilitar la visualización.",

  print_console_output:
    "El resultado del último ejemplo aparece en la consola de la plataforma, mostrando la cuenta del 1 al 10:",

  // Sección de Bucles
  loop_section_title: "Bucles de repetición",
  loop_intro1:
    "Los bucles son estructuras que permiten ejecutar un mismo conjunto de instrucciones varias veces. Son útiles para automatizar tareas repetitivas como contar, mostrar mensajes o manipular listas.",
  loop_intro2:
    "En la plataforma, los bloques de bucle están en la categoría <strong>Control</strong> y ofrecen varios tipos con diferentes propósitos.",

  loop_repeat_times_title: "1. Repetición con número fijo",
  loop_repeat_times_desc:
    "El bloque <code>repite X veces</code> ejecuta un conjunto de instrucciones un número determinado de veces. Ideal para contar o repetir acciones simples.",
  loop_repeat_times_explanation:
    "En este ejemplo, usamos una variable <code>contador</code> para contar hasta 5. En cada repetición, se imprime el valor actual.",

  loop_forever_title: "2. Repite mientras verdadero",
  loop_forever_desc:
    "El bloque <code>repite mientras verdadero</code> ejecuta las instrucciones continuamente, sin detenerse. Es muy usado en proyectos de robótica donde el programa debe funcionar todo el tiempo que el sistema esté encendido.",
  loop_forever_explanation:
    "En este ejemplo, la variable <code>contador</code> se incrementa cada segundo y su valor se imprime repetidamente en la consola.",

  loop_repeat_while_title: "3. Repetición mientras se cumpla una condición",
  loop_repeat_while_desc:
    "El bloque <code>repite mientras</code> ejecuta instrucciones mientras la condición definida sea verdadera.",
  loop_repeat_while_explanation:
    "En este ejemplo, la variable <code>numero</code> se incrementa hasta llegar a 5. El bucle termina cuando la condición <code>numero < 5</code> deja de cumplirse.",

  loop_count_title: "4. Bucle con contador personalizado",
  loop_count_desc:
    "El bloque <code>contar con i desde X hasta Y por Z</code> permite controlar el valor inicial, final y el incremento.",
  loop_count_explanation:
    "En este ejemplo, imprimimos la tabla del 2 multiplicando el valor de <code>i</code> en cada repetición.",

  loop_for_each_title: "5. Repetición para cada elemento de una lista",
  loop_for_each_desc:
    "El bloque <code>para cada elemento en la lista</code> recorre todos los elementos. Ideal para procesar o mostrar información.",
  loop_for_each_explanation:
    "Aquí tenemos una lista de nombres. El bucle imprime un nombre en cada vuelta hasta que se terminen.",

  loop_break_title: "6. Interrumpir el bucle con una condición",
  loop_break_desc:
    "El bloque <code>termina el bucle</code> permite detener la ejecución antes de que se complete.",
  loop_break_explanation:
    "En este ejemplo, contamos del 1 al 10 pero detenemos el bucle cuando el valor alcanza 6.",

  var_loop_print_end:
    "Todos los resultados de los ejemplos anteriores pueden verse en la consola de la plataforma.",

  // Página de Sensores
  sensor_title: "Sensores",
  sensor_section_title: "Sensores en Robótica",
  sensor_intro1:
    "Los sensores son componentes que permiten a los robots y sistemas embebidos percibir el entorno que los rodea. Capturan información como temperatura, luz, distancia, humedad, entre otros, y convierten estos datos en señales que pueden ser procesadas.",
  sensor_intro2:
    "En la plataforma, los bloques relacionados con sensores están disponibles en la categoría <strong>Sensores</strong>.",

  // Sección Sensor Infrarrojo
  sensor_ir_title: "Sensor Infrarrojo (IR)",

  sensor_ir_desc1:
    "El sensor infrarrojo (IR) es un componente digital simple y muy utilizado en la robótica, especialmente en proyectos como robots seguidores de línea. Detecta la presencia o ausencia de objetos mediante la reflexión de luz infrarroja, devolviendo valores digitales: <strong>1</strong> cuando no hay reflexión y <strong>0</strong> cuando detecta un objeto cercano.",

  sensor_ir_desc2:
    "Este sensor tiene <strong>3 pines</strong> (VCC, GND y Señal) y puede conectarse fácilmente a la <strong>Amado Board</strong> utilizando los pines de entrada digital como <code>D35</code>, <code>D39</code>, <code>D36</code> y <code>D34</code>. La placa ya cuenta con un espacio adecuado para una conexión directa, facilitando el montaje.",

  sensor_ir_desc3:
    "Además de robots seguidores de línea, el sensor IR puede ser usado en sistemas de conteo, barreras de seguridad, detección de presencia de objetos y otras aplicaciones que requieren detección simple de obstáculos.",

  sensor_ir_example_title: "Ejemplo: lectura continua del sensor IR",

  sensor_ir_steps: "¿Qué hace este programa?",
  ir_sensor_step1: "Lee continuamente el valor digital del pin D35 donde está conectado el sensor IR.",
  ir_sensor_step2: "Almacena ese valor en la variable valor_sensor.",
  ir_sensor_step3: "Imprime el valor en la consola (0 o 1), facilitando el monitoreo de la lectura.",
  ir_sensor_step4: "Espera 500 milisegundos antes de realizar la siguiente lectura.",


  // Sensor de Temperatura y Humedad
  sensor_dht_title: "Sensor de Temperatura y Humedad DHT11/22",
  sensor_dht_desc1:
    "El sensor DHT11/22 se utiliza para medir dos variables ambientales importantes: <strong>temperatura</strong> y <strong>humedad relativa</strong>. Es muy común en proyectos de automatización, estaciones meteorológicas y control ambiental.",
  sensor_dht_desc2:
    "Para que el sensor funcione correctamente con la <strong>Amado Board</strong>, debe estar conectado a un <strong>pin digital</strong>. Recomendamos usar los pines D5, D15, D16, D17, D18, D19, D21, D22 o D23. En este ejemplo, usaremos el pin <code>D17</code>.",
  sensor_dht_desc3: "¿Cómo funciona el ejemplo anterior?",
  sensor_dht_step1:
    "Inicializamos el sensor DHT11/22 e indicamos el pin de conexión.",
  sensor_dht_step2:
    "Entramos en un bucle que se repite continuamente mientras el sistema esté encendido.",
  sensor_dht_step3:
    "En cada repetición, se actualizan y almacenan las lecturas de <strong>temperatura</strong> y <strong>humedad</strong> en variables.",
  sensor_dht_step4:
    "Estos valores se muestran en la consola usando el bloque <code>imprime</code>.",
  sensor_dht_step5:
    "Una pausa de 1 segundo entre lecturas es muy importante para asegurar el buen funcionamiento del sensor.",

  // Sensor Ultrasónico
  sensor_ultra_title: "Sensor de Distancia Ultrasónico HCSR04",
  sensor_ultra_desc1:
    "El sensor ultrasónico HCSR04 se utiliza para medir distancias con precisión utilizando ondas sonoras. Envía una señal sonora (trigger) y mide el tiempo hasta que el eco regresa tras rebotar en un objeto. Con base en este tiempo, se calcula la distancia.",
  sensor_ultra_desc2:
    "La <strong>Amado Board</strong> tiene un espacio específico para conectar este sensor directamente a los pines <code>D17</code> (trigger) y <code>D34</code> (echo), facilitando su uso en proyectos de robótica.",
  sensor_ultra_desc3: "¿Cómo funciona el ejemplo anterior?",
  sensor_ultra_step1:
    "Inicializamos el sensor especificando los pines trigger (D17) y echo (D34), además del tiempo de espera.",
  sensor_ultra_step2:
    "Usamos un <strong>bucle continuo</strong> para medir la distancia repetidamente.",
  sensor_ultra_step3:
    "En cada repetición, el valor de la distancia se almacena en una variable.",
  sensor_ultra_step4:
    "El valor se imprime en la consola para monitorear la lectura en tiempo real.",
  sensor_ultra_step5:
    "Agregamos una pausa de 500 milisegundos para evitar lecturas demasiado rápidas y asegurar la estabilidad.",
  sensor_ultra_note:
    "Nota: Las lecturas pueden variar, mostrando valores muy altos o incluso -1. Para mejorar la fiabilidad, implementa un filtro simple que descarte lecturas fuera del rango esperado.",

  // Módulo RFID
  sensor_rfid_title: "Lector RFID RC522",
  sensor_rfid_desc1:
    "El RFID (Identificación por Radiofrecuencia) es una tecnología usada para identificar objetos o personas mediante tarjetas o etiquetas que emiten señales. Es ampliamente utilizada en sistemas de acceso, control de asistencia y rastreo de activos.",
  sensor_rfid_desc2:
    "El módulo utilizado en este ejemplo es el RC522, que se comunica por SPI. Lee el UID (identificador único) de las tarjetas RFID y también puede acceder a la memoria interna de la tarjeta para leer y escribir datos.",
  sensor_rfid_desc3:
    "La conexión del módulo a la Amado Board debe seguir correctamente la asignación de pines. Algunos nombres coinciden, otros son distintos entre el módulo, el bloque y la placa. Aquí la correspondencia recomendada:",
  sensor_rfid_map1: "3.3V → 3.3V",
  sensor_rfid_map2: "GND → GND",
  sensor_rfid_map3: "SCK (módulo) = SCK en el bloque = D18 / CLK en la placa",
  sensor_rfid_map4: "MOSI = MOSI en el bloque = D23 / MOSI en la placa",
  sensor_rfid_map5: "MISO = MISO en el bloque = D19 / MISO en la placa",
  sensor_rfid_map6: "RST = RST en el bloque = D22 / SCL en la placa",
  sensor_rfid_map7:
    "SDA (del módulo) debe conectarse al CS en el bloque, se recomienda usar D5 como en la imagen.",
  sensor_rfid_desc4:
    "Aunque los pines RST y CS se pueden conectar a otros pines digitales (como D17, D21 o D22), se recomienda seguir el ejemplo para mayor compatibilidad.",
  rfid_libraries_desc:
    "Para que los bloques del lector RFID RC522 funcionen correctamente, es necesario instalar la biblioteca <code>mfrc522</code>, que permite la comunicación y lectura de tarjetas RFID.",
  rfid_verify_library:
    "Después de hacer clic en el botón <strong>“Instalar biblioteca”</strong>, puedes verificar la instalación mediante el mensaje en la consola: <code>Instalación de la biblioteca mfrc522 completada.</code>",
  rfid_verify_file:
    "También puedes confirmar la presencia de la biblioteca abriendo la pestaña <strong>Archivos</strong>. Haz doble clic en el botón de actualizar y verifica si el archivo <code>mfrc522.py</code> aparece listado en la memoria de la placa.",
  sensor_rfid_desc6:
    "A continuación, vemos un programa básico que lee una tarjeta RFID y muestra los resultados en la consola.",
  sensor_rfid_expl_title: "¿Cómo funciona el ejemplo anterior?",
  sensor_rfid_step1:
    "Inicializamos el módulo indicando todos los pines de conexión SPI.",
  sensor_rfid_step2:
    "Entramos en un bucle continuo que verifica constantemente si hay una tarjeta presente.",
  sensor_rfid_step3:
    "Si se detecta una tarjeta (estado = 0), se muestra un mensaje en la consola y se imprime el UID.",
  sensor_rfid_step4:
    "Incluso cuando no hay tarjeta, se muestran el estado y el tipo de etiqueta para facilitar el depurado.",
  sensor_rfid_step5:
    "Agregamos un retardo de 500 milisegundos para evitar repeticiones muy rápidas.",
  sensor_rfid_console_desc:
    "A continuación puedes ver cómo aparecen los resultados en la consola de la plataforma, mostrando el estado, tipo de etiqueta y UID cuando se detecta una tarjeta.",

  // Página de Actuadores
  // Sección de Actuadores
  actuator_section_title: "Actuadores",
  actuator_introduction: "Actuadores en la robótica",
  actuator_intro1:
    "Los actuadores son dispositivos que reciben comandos de un sistema y realizan una acción física en el mundo real. Transforman señales eléctricas en movimiento, sonido, luz, calor u otras formas de respuesta.",
  actuator_intro2:
    "En la robótica y la automatización, los actuadores son esenciales para interactuar con el entorno, permitiendo encender luces, activar motores, abrir válvulas, hacer sonar timbres, entre otros.",
  actuator_intro3:
    "En la plataforma, los bloques de actuadores están disponibles en la categoría <strong>Salidas y Actuadores</strong>. Cada tipo de actuador tendrá sus propios bloques con comandos específicos.",

  // Sección Módulo Relé
  relay_title: "Módulo Relé",
  relay_desc1:
    "El relé es un componente que funciona como un interruptor controlado electrónicamente. Permite encender o apagar dispositivos de mayor potencia (como lámparas, ventiladores o electrodomésticos) utilizando una señal digital de la placa.",
  relay_desc2:
    "En el bloque de relé, puedes elegir el pin al que está conectado y el comando deseado: <strong>encender</strong> o <strong>apagar</strong>. Es importante recordar que el módulo relé debe estar correctamente alimentado (generalmente con 5V y GND), y que la carga conectada debe estar aislada y bien conectada para mayor seguridad.\n\nImportante: muchos módulos relé se activan con señal 0 (nivel lógico bajo). Es decir, al usar el comando 'apagar' en el bloque, el relé se activará (encendiendo el dispositivo). Por el contrario, el comando 'encender' en el bloque desactivará el relé (apagando el dispositivo).",
  relay_example_title: "Ejemplo: encender una lámpara con retardo",
  relay_example_desc:
    "En el ejemplo siguiente, usamos el bloque de relé para simular el control de una lámpara. Al iniciar el programa, el relé se activa (simulando que la lámpara se enciende), y después de 3 segundos se apaga. Este tipo de control puede utilizarse en aplicaciones como temporizadores, simulación de presencia o automatización del hogar.",
  relay_example_note:
    "Este ejemplo simple de temporizador también podría utilizarse dentro de una <strong>condición</strong> (por ejemplo, al detectar una tarjeta RFID, presencia, horario, etc.) para tomar decisiones automáticas en el programa.",

  // Sección Servo Motor
  servo_title: "Servo Motor",
  servo_desc1:
    "El servo motor es un actuador muy utilizado en proyectos de robótica y automatización. Permite posicionar un eje en ángulos específicos, generalmente entre 0 y 180 grados. Es ideal para controlar puertas, brazos mecánicos, palancas, ejes u otros sistemas que requieren movimientos precisos y controlados.",
  servo_desc2:
    "En la plataforma, el control del servo se realiza en dos pasos: primero usamos el bloque <strong>Iniciar servo motor</strong> para definir el pin de conexión y el nombre del servo, y luego usamos el bloque <strong>Mover servo</strong> para indicar el ángulo deseado. Es posible utilizar nombres personalizados (como servo1, servo2, etc.), permitiendo el control de múltiples servos en un mismo proyecto.",
  servo_desc3:
    "La <strong>Amado Board</strong> posee un lugar específico para conectar servos: los pines <strong>D15</strong> y <strong>D16</strong> están identificados como <code>SERVO A</code> y <code>SERVO B</code> respectivamente. Junto a estos pines hay un conjunto de 3 pines rotulados como <code>3.3V</code>, <code>VS</code> y <code>5V</code>. Para que el servo reciba alimentación correctamente, es necesario <strong>hacer un puente entre el pin VS y el pin 5V</strong>. Esto asegura que el pin de señal tenga energía para mover el servo con estabilidad.",
  servo_desc4:
    "Los servos suelen tener cables con colores estándar: <strong>marrón</strong> (GND), <strong>rojo</strong> (VCC) y <strong>amarillo</strong> (señal). La placa ya posee el espacio adecuado para conectar estos tres pines directamente, facilitando la instalación.",

  servo_basic_title: "Ejemplo 1: control de posiciones fijas",
  servo_basic_desc:
    "Este ejemplo mueve el servo a tres posiciones fijas: 0°, 90° y 180°, con un pequeño intervalo entre los movimientos. Es ideal para demostrar el funcionamiento básico del servo y cómo controlar los ángulos directamente.",
  servo_basic_steps: "¿Qué hace este programa?",
  servo_basic_step1: "Inicializa el servo en el pin D15.",
  servo_basic_step2: "Mueve el servo al ángulo 0°, espera 1 segundo.",
  servo_basic_step3:
    "Mueve al ángulo 90°, luego a 180°, con pausas entre cada posición.",
  servo_basic_step4: "El ciclo se repite continuamente.",

  servo_smooth_title: "Ejemplo 2: movimiento continuo con bucle",
  servo_smooth_desc:
    "En este ejemplo usamos un <strong>bucle for</strong> para mover suavemente el servo de 0° a 180° y regresar. Esto crea un movimiento fluido y continuo, útil para simulaciones de radar, barridos o movimientos controlados en un brazo robótico.",
  servo_smooth_steps: "¿Qué hace este programa?",
  servo_smooth_step1: "Inicializa el servo y entra en un bucle continuo.",
  servo_smooth_step2:
    "Utiliza un bucle para moverse de 0° a 180°, esperando 10 ms en cada paso.",
  servo_smooth_step3:
    "Después de una pausa, repite el movimiento de 180° a 0°.",

  servo_ultra_title: "Ejemplo 3: control mediante sensor ultrasónico",
  servo_ultra_desc:
    "Aquí combinamos el servo con un <strong>sensor ultrasónico</strong> para simular una <strong>puerta automática</strong> o una barrera de estacionamiento. Si la distancia es menor a 100mm, el servo abre la puerta (ángulo 90°). En caso contrario, permanece cerrada (ángulo 0°).",
  servo_ultra_tip:
    "La comparación se realiza con el bloque <code>si</code>, que puede ampliarse con la opción <code>sino</code>, activada desde el engranaje del bloque. La operación <code><</code> utilizada está disponible en la categoría <strong>Matemáticas → Lógica</strong>.",
  servo_ultra_steps: "¿Qué hace este programa?",
  servo_ultra_step1: "Inicializa el servo y el sensor ultrasónico.",
  servo_ultra_step2: "Lee continuamente la distancia (en milímetros).",
  servo_ultra_step3:
    "Si la distancia es menor a 100 mm, el servo se mueve a 90°.",
  servo_ultra_step4: "En caso contrario, el servo vuelve a 0°.",
  servo_ultra_step5: "La lectura se realiza cada 150 ms.",

  // Sección Motor DC
  motor_title: "Motor DC",
  motor_desc1:
    "Los motores de corriente continua (DC) se utilizan ampliamente en proyectos de robótica para mover vehículos, brazos mecánicos, cintas transportadoras, entre otros. Permiten controlar la rotación y el sentido mediante señales digitales.",
  motor_desc2:
    "En la plataforma, controlamos el motor DC usando tres pines: <strong>PWM</strong> para la potencia (velocidad) y <strong>DIR1</strong> y <strong>DIR2</strong> para la dirección. El bloque <code>Iniciar motor DC</code> permite seleccionar los pines y dar un <strong>nombre personalizado</strong> al motor, como motor1, motor2, etc. Esto permite controlar múltiples motores de forma independiente.",
  motor_desc3:
    "La <strong>Amado Board</strong> ya cuenta con un espacio físico adecuado con bornes de tornillo azules en los laterales, facilitando la conexión directa de hasta dos motores. Estos bornes están conectados internamente a los pines PWM, DIR1 y DIR2.",
  motor_desc4:
    "La velocidad del motor se controla con valores entre <code>0</code> (apagado) y <code>1023</code> (potencia máxima). La dirección se define con el bloque de dirección: <code>1</code> hacia adelante, <code>2</code> hacia atrás y <code>0</code> para detener. También hay un bloque <strong>Detener motor</strong> que puede usarse en cualquier momento para detener el movimiento.",

  motor_example_title: "Ejemplo: motor alternando dirección",
  motor_example_desc:
    "El siguiente ejemplo demuestra el uso básico del motor DC alternando su dirección. El motor gira en un sentido por unos segundos, se detiene, luego gira en sentido contrario.",
  motor_example_steps: "¿Qué hace este programa?",
  motor_example_step1: "Inicializa el motor usando los pines PWM, DIR1 y DIR2.",
  motor_example_step2:
    "Configura la máxima potencia (1023) y gira el motor hacia adelante (dirección 1).",
  motor_example_step3:
    "Después de 2 segundos, detiene el motor y espera otros 2 segundos.",
  motor_example_step4:
    "Gira el motor en sentido contrario (dirección 2), espera y se detiene nuevamente.",
  motor_example_step5: "El ciclo se repite de forma continua.",
  motor_extra_note:
    "Además de pruebas básicas, el control de motores DC es fundamental en proyectos como robots seguidores de línea o que evitan obstáculos. En estos casos, los sensores determinan el comportamiento del motor, permitiendo que el robot se mueva de forma autónoma según el entorno.",

  // Sección Buzzer
  buzzer_title: "Zumbador (Buzzer)",
  buzzer_intro1:
    "El zumbador, también conocido como buzzer, es un actuador que emite sonidos simples o melodías. Se puede utilizar para alarmas, alertas, confirmaciones o incluso para reproducir música temática. La placa Amado Board incluye un buzzer integrado en el pin D4, listo para usarse.",
  buzzer_libraries_title: "Instalación de bibliotecas",
  buzzer_libraries_desc:
    "Para que los bloques de sonido y música funcionen correctamente, es necesario instalar dos bibliotecas:",
  buzzer_verify_library:
    "Después de hacer clic en “Instalar biblioteca”, puedes verificar la instalación en la consola: Instalación de la biblioteca rtttl finalizada.",
  buzzer_verify_file:
    "También puedes confirmar la presencia de la biblioteca desde la pestaña Archivos. Haz doble clic en el botón de actualizar y verifica si aparecen los archivos <code>rtttl.py</code> y <code>songs.py</code>.",

  buzzer_block_freq_title: "1. Reproducir sonido por frecuencia",
  buzzer_block_freq_desc:
    "Este bloque reproduce un sonido con una frecuencia específica (en Hz) durante un tiempo determinado (en segundos). Por ejemplo, 1000 Hz genera un tono agudo. Usar 0 o -1 hace que el sonido sea continuo.",

  buzzer_block_note_title: "2. Reproducir sonido por nota musical",
  buzzer_block_note_desc:
    "En este bloque puedes seleccionar una nota musical (como D3 o B1) y definir la duración en segundos. Ideal para crear melodías manualmente.",

  buzzer_block_music_title: "3. Reproducir música predefinida",
  buzzer_block_music_desc:
    "Puedes seleccionar canciones temáticas integradas como Super Mario, Star Wars o Picaxe. Solo elige el nombre desde la lista.",

  buzzer_block_user_title: "Nota: melodías creadas por el usuario",
  buzzer_block_user_desc:
    "Existe un bloque llamado “Reproducir buzzer en el pin con melodía”. Este bloque se usa junto con la pestaña Música para reproducir canciones compuestas por el usuario. Será explicado en una sección específica más adelante.",

  kw_introduction: "introducción",
  kw_beginners: "principiantes",
  kw_block_programming: "programación en bloques",
  kw_dblocks_basics: "dblocks básico",
  kw_interactive_projects: "proyectos interactivos",
  kw_amadoboard: "amadoboard",
  kw_hardware: "hardware",
  kw_board_features: "características de la placa",
  kw_esp32_board: "placa esp32",
  kw_pinout: "pinout",
  kw_environment_setup: "configuración de entorno",
  kw_drivers: "controladores",
  kw_micropython_install: "instalar micropython",
  kw_amadoboard_config: "configuración amadoboard",
  kw_variables: "variables",
  kw_loops: "bucles",
  kw_print_console: "imprimir en consola",
  kw_control_structures: "estructuras de control",
  kw_programming_fundamentals: "fundamentos de programación",
  kw_logic_operators: "operadores lógicos",
  kw_math_operators: "operadores matemáticos",
  kw_boolean_logic: "lógica booleana",
  kw_conditional_statements: "declaraciones condicionales",
  kw_digital_io: "e/s digital",
  kw_digital_input: "entrada digital",
  kw_digital_output: "salida digital",
  kw_gpio: "gpio",
  kw_led_control: "control de led",
  kw_analog_io: "e/s analógica",
  kw_analog_input: "entrada analógica",
  kw_analog_output: "salida analógica",
  kw_adc: "adc",
  kw_pwm_control: "control pwm",
  kw_sensors_dblocks: "sensores dblocks",
  kw_data_collection: "recolección de datos",
  kw_environment_monitoring: "monitoreo ambiental",
  kw_sensor_integration: "integración de sensor",
  kw_ldr: "ldr",
  kw_dht11: "dht11",
  kw_actuators_dblocks: "actuadores dblocks",
  kw_device_control: "control de dispositivo",
  kw_motors_control: "control de motor",
  kw_servo_motor: "servomotor",
  kw_relay_module: "módulo relé",
  kw_music_dblocks: "música dblocks",
  kw_sound_programming: "programación de sonido",
  kw_melody_composition: "composición de melodía",
  kw_buzzer_control: "control de zumbador",
  kw_display_dblocks: "pantalla dblocks",
  kw_oled_display: "pantalla oled",
  kw_text_on_display: "texto en pantalla",
  kw_show_sensor_data: "mostrar datos de sensor",
  kw_dblocks_resources: "recursos dblocks",
  kw_dblocks_features: "funcionalidades dblocks",
  kw_advanced_features: "características avanzadas",
  kw_project_development: "desarrollo de proyecto",
  //Keywords bluetooth
  kw_bluetooth: "bluetooth",
  kw_ble: "bluetooth de baja energía",
  kw_bluetooth_esp32: "bluetooth esp32",
  kw_ble_esp32: "ble esp32",
  kw_bluetooth_control: "control por bluetooth",
  kw_bluetooth_communication: "comunicación bluetooth",
  kw_bluetooth_projects: "proyectos con bluetooth",
  kw_ble_projects: "proyectos con ble",
  kw_app_integration: "integración con aplicación",
  kw_bluefruit_app: "aplicación bluefruit",
  kw_data_plotting: "visualización de datos",
  kw_graph_plotting: "gráfico de datos",
  kw_remote_control: "control remoto",
  kw_realtime_data: "datos en tiempo real",
  kw_control_pad: "control pad",
  kw_bluetooth_plotter: "plotter bluetooth",
  kw_bluetooth_graphs: "gráficos bluetooth",
  kw_bluetooth_sensors: "sensores bluetooth",
  kw_interactive_control: "control interactivo",
  kw_wireless_control: "control inalámbrico",

  //Pagina display
  display_section_title: "Pantalla OLED SSD1306",
  display_intro1: "La pantalla OLED SSD1306 es una pantalla pequeña con comunicación I2C, muy utilizada en proyectos de electrónica y robótica para mostrar información como textos, valores de sensores o mensajes del sistema.",
  display_intro2: "En la plataforma, los bloques para controlar la pantalla se encuentran en la categoría Pantallas. Antes de usarla, es necesario instalar la biblioteca ssd1306 haciendo clic en el bloque Instalar biblioteca: ssd1306.",
  display_connection_info: "La placa Amado tiene un espacio dedicado para conectar la pantalla, identificado en la propia placa con el nombre OLED DISPLAY. Este conector utiliza comunicación I2C, y los pines correspondientes son: SDA en el pin D21 y SCL en el pin D22. Simplemente conecta el módulo OLED en el lugar correcto e inicia la comunicación con esos pines en el bloque de inicialización.",
  display_blocks_info: "Para que el texto o valor aparezca correctamente en la pantalla, es fundamental seguir el orden correcto de los bloques: 1) limpiar la pantalla, 2) escribir el contenido (mensaje o número) y 3) actualizar la pantalla. El bloque de actualización realmente envía el contenido a la pantalla; sin él, no se mostrará nada.",

  display_example1_title: "Ejemplo 1: Escribir texto fijo en la pantalla",
  display_example1_desc: "En este ejemplo mostramos cómo posicionar un texto estático en la pantalla usando los bloques adecuados. Este es el primer paso para cualquier proyecto con pantalla.",
  display_example1_steps: "¿Qué hace este programa?",
  display_example1_step1: "Inicializa la pantalla con los pines correctos (I2C: 1, SCL: 22, SDA: 21).",
  display_example1_step2: "Limpia la pantalla para asegurarse de que no haya restos de texto anterior.",
  display_example1_step3: "Escribe el texto \"Hello\" en la posición deseada de la pantalla.",
  display_example1_step4: "Actualiza la pantalla para que aparezca el texto.",

  display_example3_title: "Ejemplo 2: Actualizar valor con bucle",
  display_example3_desc: "Este ejemplo demuestra cómo crear un contador que se actualiza constantemente en la pantalla. Ideal para aprender a manipular variables visuales.",
  display_example3_steps: "¿Qué hace este programa?",
  display_example3_step1: "Inicializa la pantalla.",
  display_example3_step2: "Crea una variable que incrementa su valor cada segundo.",
  display_example3_step3: "Limpia la pantalla, muestra el valor de la variable y actualiza la pantalla continuamente.",

  display_example4_title: "Ejemplo 3: Mostrar valor del sensor LDR",
  display_example4_desc: "Aquí mostramos cómo integrar la pantalla con sensores. En este caso, mostramos el valor de luminosidad leído por un sensor LDR.",
  display_example4_steps: "¿Qué hace este programa?",
  display_example4_step1: "Inicializa la pantalla y configura la lectura del sensor LDR.",
  display_example4_step2: "Lee continuamente el valor de luminosidad ambiental.",
  display_example4_step3: "Muestra el valor en la pantalla, actualizando cada 500 milisegundos.",

  // Sección Lógica y Matemáticas'
  logic_math_intro_title: "Lógica y Matemáticas",
  logic_math_intro1: "Los bloques de lógica y matemáticas son fundamentales en la programación. Permiten crear condiciones, realizar cálculos, comparar valores y tomar decisiones. Están presentes en prácticamente todo tipo de proyecto — desde lecturas de sensores hasta control de motores y ejecución de acciones basadas en reglas.",
  logic_math_intro2: "La categoría Matemáticas contiene operaciones como suma, resta, multiplicación, división, redondeo, raíz cuadrada, seno, mapeo de valores, entre otros. La categoría Lógica ofrece comparadores (como =, <, >), operadores lógicos (Y, O) y bloques de decisión como si, sino y sino si.",

  logic_math_example1_title: "Ejemplo 1: Verificar si un número fijo es mayor que 10",
  logic_math_example1_desc: "En este ejemplo usamos los bloques si y sino para verificar si un valor fijo es mayor que 10. El bloque de decisión (si) permite ejecutar comandos solo cuando una condición es verdadera. La comparación se hace con el operador >.",
  logic_math_context1: "Este tipo de estructura es muy común en proyectos de robótica — por ejemplo, verificar si un sensor detectó un obstáculo para activar o detener un motor.",
  logic_math_context2: "La estructura si → sino si → sino se crea haciendo clic en el engranaje del bloque “si”. Esto permite crear condiciones múltiples y tomar decisiones más completas. Es común en proyectos como robots seguidores de línea, control climático o decisiones basadas en múltiples sensores.",
  logic_math_context3: "Esta estructura condicional es muy útil en sistemas embebidos de automatización, donde se deben combinar diferentes sensores para decidir cuándo activar dispositivos como ventiladores, extractores o alertas.",
  logic_math_example1_steps: "¿Qué hace este programa?",
  logic_math_example1_step1: "Crea una variable con el valor 15.",
  logic_math_example1_step2: "Verifica si el número es mayor que 10.",
  logic_math_example1_step3: "Si es verdadero, imprime 'Mayor que 10'; de lo contrario, imprime 'Menor o igual a 10'.",
  logic_math_example1_console: "Los resultados de la prueba se muestran en la consola de la plataforma. Para visualizarla, haz clic en la pestaña Consola en la parte superior de la pantalla después de ejecutar el programa.",

  logic_math_example2_title: "Ejemplo 2: Convertir valor analógico en porcentaje",
  logic_math_example2_desc: "En este ejemplo, pedimos al usuario que ingrese un valor numérico en la consola para simular la lectura de un sensor. Luego usamos el bloque mapear de la categoría Matemáticas, que sirve para convertir un valor de un rango a otro. Este bloque es muy útil en proyectos de robótica para transformar lecturas de sensores (como luz, distancia o temperatura) en escalas más comprensibles, como porcentajes. Esto facilita la toma de decisiones o la visualización de datos para el usuario.",
  logic_math_example2_steps: "¿Qué hace este programa?",
  logic_math_example2_step1: "Pide al usuario un valor numérico para simular una lectura analógica.",
  logic_math_example2_step2: "Convierte este valor en un porcentaje usando el bloque mapear.",
  logic_math_example2_step3: "Imprime el valor convertido (en %) en la consola.",
  logic_math_example2_console: "El número se ingresa directamente en la consola, ubicada en la parte superior de la pantalla. El valor convertido se muestra a continuación para su seguimiento en tiempo real.",

  logic_math_example3_title: "Ejemplo 3: Control de ventilación con Y, O y sino",
  logic_math_example3_desc: "En este ejemplo simulamos la lógica de un sistema de ventilación inteligente que considera tanto la temperatura como la humedad del ambiente. Usamos los operadores lógicos Y y O junto con los bloques condicionales si y sino si para definir el comportamiento del sistema según los valores.",
  logic_math_example3_steps: "¿Qué hace este programa?",
  logic_math_example3_step1: "Crea dos variables con valores fijos para temperatura y humedad.",
  logic_math_example3_step2: "Si temperatura > 30 Y humedad > 70, imprime 'Activar ventilador y deshumidificador'.",
  logic_math_example3_step3: "Sino si temperatura > 30 O humedad > 70, imprime 'Activar solo el ventilador'.",
  logic_math_example3_step4: "De lo contrario, imprime 'Ambiente confortable'.",
  logic_math_example3_console: "Los resultados de las decisiones se muestran en la consola, lo que permite seguir el comportamiento lógico del programa.",
  logic_math_example3_tip: "Puedes cambiar los valores de las variables de temperatura y humedad para observar cómo cambia el comportamiento del programa. Esto ayuda a comprender mejor el uso de condiciones combinadas y operadores lógicos en situaciones reales.",



  //Pagina musica
  music_section_title: "Música",
  music_section_intro: "En esta sección, aprenderemos a usar la pestaña Música de la plataforma para componer melodías personalizadas de forma visual mediante un piano roll interactivo. Estas melodías se pueden probar y luego usar en bloques con el zumbador.",
  music_features_intro: "La interfaz ofrece varios controles útiles:",
  music_feature_trash: "Papelera: borra toda la melodía actual.",
  music_feature_save: "Guardar melodía: guarda la melodía actual, que estará disponible en el bloque “Reproducir zumbador con melodía”.",
  music_feature_play: "Reproducir: ejecuta la melodía creada para escucharla directamente en la plataforma.",
  music_feature_pause: "Pausa: pausa la reproducción de la melodía.",
  music_feature_bpm: "BPM: define la velocidad de la melodía. El valor predeterminado es 120, pero se puede ajustar según sea necesario.",
  music_feature_download: "Descargar: exporta la melodía como archivo .json.",
  music_feature_import: "Importar: permite cargar un archivo .json con una melodía guardada anteriormente.",

  music_editor_info: "El piano roll funciona de la siguiente manera: las columnas representan el tiempo y las filas representan las notas musicales. Puedes seleccionar una nota por columna. Si omites una columna, ese momento será un silencio.",

  music_example1_title: "Ejemplo: Creando la melodía \"Do-Re-Mi-Fa-Sol-La-Si\"",
  music_example1_desc: "Vamos a crear una melodía simple utilizando las notas musicales básicas.",
  music_example1_step1: "Después de configurar la secuencia de la melodía, haz clic en Reproducir para escucharla. Verás una línea roja moviéndose de izquierda a derecha, indicando el progreso de la ejecución.",
  music_example1_step2: "Si estás satisfecho con el resultado, haz clic en Guardar melodía e ingresa un nombre (como do-re-mi) en la ventana que aparecerá.",
  music_example1_step3: "Puedes seguir editando la melodía o agregar nuevos fragmentos después. También puedes exportar la melodía usando el botón Exportar, generando un archivo .json que puede ser compartido o guardado. Usa Importar para abrir una melodía existente.",


  music_example2_title: "Reproducir la melodía con el zumbador",
  music_example2_desc: "Después de guardar la melodía, ve a la pestaña Bloques. En Salidas y Actuadores → Zumbador, encontrarás el bloque Reproducir zumbador en el pin. Al seleccionar la melodía creada, podrás reproducirla con el zumbador de la placa.",
  music_example2_desc1: "En el ejemplo anterior, usamos el pin D4 / BUZZER porque el buzzer ya está integrado en la placa Amado Board en ese pin. Sin embargo, se pueden usar buzzers externos en otros pines, simplemente seleccionando el pin correspondiente en el bloque.",
  music_example2_desc2: "Después de conectar el bloque en el programa y hacer clic en Reproducir, el buzzer ejecutará la melodía creada. Puedes componer melodías más largas y usar varios bloques en secuencia para tocar diferentes partes u organizar la ejecución de secciones de la música.",

  music_extra_info_title: "Consejos adicionales",
  music_extra_info: "Si haces clic derecho sobre el bloque de melodía, verás opciones útiles como Eliminar o Exportar esa melodía individualmente.",

  music_example3_title: "Ejemplo: Melodía “Cumpleaños Feliz”",
  music_example3_desc: "En este ejemplo, creamos una versión simple de la melodía “Cumpleaños Feliz” utilizando el editor de música de la plataforma. Es una excelente forma de practicar composición, trabajar con ritmos y probar la reproducción con el zumbador.",
  music_example3_notes: "Las notas utilizadas, en orden, son: C4, C4, D4, C4, F4, E4 / C4, C4, D4, C4, G4, F4. Cada grupo representa una frase musical, y puedes continuar creando las siguientes partes de la canción de la misma manera.",
  music_example3_bpm: "Ten en cuenta que el BPM fue ajustado a 130, lo que hace que la melodía sea un poco más rápida. Puedes probar diferentes valores de BPM para ajustar la velocidad según tu preferencia.",
  music_example3_tips: "Este tipo de ejercicio ayuda a comprender cómo el tiempo y las pausas influyen en la ejecución de la melodía. También permite practicar la organización de las notas en el piano roll y explorar posibilidades creativas.",

  music_section_intro_title: "Introducción",


  //Pagina recursos y funcionalidades
  resources_section_title: "Recursos y Funcionalidades",
  resources_intro: "En esta sección presentaremos algunas funciones adicionales de la plataforma que pueden facilitar el uso y la organización de tus proyectos. Estos detalles a menudo pasan desapercibidos, pero hacen que la experiencia con el entorno sea aún más eficiente.",

  resources_project_block_title: "Bloque de Datos del Proyecto",
  resources_project_block_desc: "Siempre que se crea un nuevo proyecto, el bloque Datos del proyecto aparece automáticamente. Es muy útil, ya que permite rellenar el nombre del autor, el ID del proyecto (si está integrado con IoT) y una descripción personalizada. Esta descripción se utiliza como nombre del archivo al exportar el proyecto, facilitando su identificación en la computadora.",
  resources_project_block_info: "También puedes encontrar este bloque en la categoría Funciones → Bipes e insertarlo manualmente en el proyecto si es necesario.",

  resources_mult_projects_title: "Trabajar con múltiples proyectos",
  resources_mult_projects_desc: "En la parte superior de la plataforma hay un botón de usuario (icono de perfil). Al hacer clic, se abre un panel lateral con las opciones de gestión de proyectos.",
  resources_mult_projects_usage: "Puedes crear varios proyectos haciendo clic en el botón + y cambiar entre ellos rápidamente. Esta función es excelente para organizar diferentes tareas, borradores o versiones de código.",
  resources_mult_projects_lang_title: "Idioma de la plataforma",
  resources_mult_projects_lang: "En este panel también puedes cambiar el idioma de la interfaz, eligiendo entre Portugués, Inglés o Español. Esta opción aparece en la parte inferior del panel.",

  resources_topbar_title: "Otros botones de la barra superior",
  resources_topbar_desc: "Además de la gestión de proyectos, la barra superior incluye varios otros botones útiles:",
  resources_topbar_item_python: "<strong>Python (icono)</strong>: abre directamente la página de instalación de MicroPython para tu placa.",
  resources_topbar_item_download: "<strong>Descargar</strong>: descarga el código del proyecto en formato <code>.xml</code>.",
  resources_topbar_item_upload: "<strong>Subir</strong>: permite cargar un archivo <code>.xml</code> guardado previamente.",
  resources_topbar_item_connect: "<strong>Conectar</strong>: botón con símbolo USB para conectar la placa a la plataforma.",
  resources_topbar_item_play: "<strong>Reproducir</strong>: ejecuta el programa cargado en la placa.",

  resources_save_title: "Guardar el programa en la placa (main.py)",
  resources_save_intro: "Una de las funcionalidades más importantes de la plataforma es la posibilidad de guardar el programa directamente en la memoria de la placa, permitiendo que se ejecute automáticamente cada vez que la placa sea encendida. Esto se hace guardando el código con el nombre main.py.",
  resources_save_context: "Para ello, es necesario utilizar la pestaña Archivos, que funciona como un gestor de archivos interno de la placa. Esta función es un diferencial de la plataforma, ya que permite guardar, editar, eliminar y ejecutar archivos directamente desde la memoria interna del dispositivo.",
  resources_save_steps: "Sigue los pasos a continuación para guardar tu programa como 'main.py':",
  resources_save_check: "Después de guardar, haz doble clic en el botón de actualizar para ver la lista de archivos de la placa. Verás el nuevo archivo main.py con la etiqueta run at boot, indicando que será el programa que se ejecutará automáticamente al encender la placa.",
  resources_save_edit: "Además de guardar, es posible editar o eliminar archivos directamente desde esta pestaña. Para eliminar el main.py, simplemente haz clic en el icono de la papelera junto al nombre del archivo.",
  resources_save_tip: "Nota importante",
  resources_save_note: "En algunos casos, el programa puede seguir ejecutándose incluso después de hacer clic en Detener. Si esto ocurre, haz clic en el icono de desconexión, presiona el botón de reinicio en la placa y vuelve a conectarla. El icono de reproducción debería volver a aparecer, y podrás acceder nuevamente a la memoria de la placa.",
  resources_save_note2: "Este comportamiento es común cuando deseas eliminar el archivo <code>main.py</code> o volver al uso normal con la plataforma. Siempre que finalices un proyecto y quieras usarlo con una fuente de energía externa, guárdalo como <code>main.py</code>.",

  resources_save_step1: "Asegúrate de que la <strong>placa esté conectada</strong> y <strong>no se esté ejecutando ningún programa</strong> (el botón <code>Play</code> debe estar visible).",
  resources_save_step2: "Accede a la pestaña <strong>Archivos</strong>.",
  resources_save_step3: "En la sección \"Bloques para código\", haz clic en <code>code.bipes.py</code> para ver tu programa.",
  resources_save_step4: "Cambia el nombre del archivo haciendo clic sobre <strong>code.bipes.py</strong> en la parte superior del editor y renómbralo a <code>main.py</code>.",
  resources_save_step5: "Haz clic en <strong>Guardar una copia</strong>.",

  resources_save_step1: "Asegúrate de que la <strong>placa esté conectada</strong> y que <strong>ningún programa esté en ejecución</strong> (el botón <code>Play</code> debe estar visible).",
  resources_save_step2: "Accede a la pestaña <strong>Archivos</strong>.",
  resources_save_step3: "En la sección \"Bloques a código\", haz clic en <code>code.bipes.py</code> para ver tu programa.",
  resources_save_step4: "Cambia el nombre del archivo haciendo clic sobre <strong>code.bipes.py</strong> en la parte superior del editor y renómbralo como <code>main.py</code>.",
  resources_save_step5: "Haz clic en <strong>Guardar una copia</strong>.",
  logic_and_math: "Lógica y matemáticas",

  // Página Bluetooth
  bluetooth_title: "bluetooth",
  bluetooth_section_title: "Comunicación por Bluetooth (BLE)",
  bluetooth_intro: "El Bluetooth es una tecnología de comunicación inalámbrica de corto alcance, utilizada en teléfonos móviles, auriculares, computadoras, automóviles y sistemas embebidos. Permite el intercambio de datos entre dispositivos cercanos de manera simple y sin cables.",
  bluetooth_ble_reason: "En este proyecto usamos el estándar BLE (Bluetooth Low Energy), que es el único compatible con MicroPython en el ESP32. Es ideal para sistemas con sensores, controles remotos, automatización y monitoreo con bajo consumo de energía.",
  bluetooth_project_ideas: "Con BLE, es posible crear proyectos como: control remoto de robots, envío de datos de sensores al celular, gráficos de monitoreo en tiempo real, automatización del hogar, sistemas de alarma e incluso juegos interactivos con botones virtuales.",
  bluetooth_blocks_title: "Bloques disponibles para comunicación por Bluetooth",
  bluetooth_blocks_intro: "Los bloques de Bluetooth están disponibles en la categoría Comunicación → Bluetooth. Para que el código funcione, es necesario instalar la biblioteca ble_advertising haciendo clic en el botón indicado en la interfaz.",
  bluetooth_block1: "<strong>Configurar e iniciar el Bluetooth con nombre:</strong> define el nombre del dispositivo BLE visible en el celular.",
  bluetooth_block2: "<strong>Definir los datos recibidos por Bluetooth en:</strong> almacena los datos enviados por la aplicación en una variable.",
  bluetooth_block3: "<strong>Verificar los datos recibidos:</strong> interpreta los comandos recibidos.",
  bluetooth_block4: "<strong>Configurar el visualizador para sensores:</strong> permite definir qué sensor se mostrará en el gráfico de la app.",
  bluetooth_block5: "<strong>Enviar datos al visualizador:</strong> envía valores de la aplicación al gráfico de la app.",
  bluetooth_program_title: "Programa base de comunicación por Bluetooth",
  bluetooth_tip_execution: "Este es el programa base más simple y el principal punto de partida. Con él ya podemos probar si los datos están llegando desde el celular a la placa.",
  bluetooth_program_steps: "<strong>¿Qué hace este programa?</strong>",
  bluetooth_step1: "Inicializa el BLE con el nombre meuBluetooth.",
  bluetooth_step2: "Crea la variable datos que recibe los comandos del celular.",
  bluetooth_step3: "Verifica continuamente los datos recibidos y los interpreta según el valor recibido.",
  bluetooth_connected_tip: "Después de montar, haz clic en Play y abre la pestaña Console. El mensaje “Conectado” indicará que el Bluetooth está funcionando correctamente.",
  bluetooth_app_title: "Aplicación Bluefruit Connect",
  bluetooth_app_description: "Para interactuar con el programa usamos la app Bluefruit Connect de Adafruit. Está disponible de forma gratuita para Android e iOS. Busca “Bluefruit Connect” en la tienda de aplicaciones, instálala y ábrela.",
  bluetooth_app_guide: "<strong>En la app, sigue los pasos a continuación:</strong>",
  bluetooth_app_step1: "Abre la app y selecciona el dispositivo llamado MPY ESP32. Incluso si has definido otro nombre en el bloque, este nombre puede aparecer como predeterminado.",
  bluetooth_app_step2: "Accede a la pestaña Controller y toca en Control Pad.",
  bluetooth_app_step3: "Utiliza los botones direccionales o numéricos para enviar comandos a la placa.",
  bluetooth_console_title: "Probando los botones en la consola",
  bluetooth_console_info: "Después de conectarte al dispositivo y abrir el Control Pad, presiona los botones de la app. En la consola de la IDE aparecerán mensajes como: Datos recibidos: !B507.",
  bluetooth_console_example: "En nuestra prueba, usamos los botones de flechas (arriba, abajo, izquierda y derecha). Para cada botón, la app envía dos comandos: uno al presionar y otro al soltar. Esto permite que el programa sepa cuándo se presionó y cuándo se soltó el botón.",
  bluetooth_example2_title: "Encender LEDs integrados vía Bluetooth",
  bluetooth_example2_intro: "En este ejemplo, controlaremos dos LEDs integrados de la placa mediante la app. Al presionar el botón 1, se encenderá el LED azul (pin D2). Al presionar el botón 2, se activará el LED verde (pin D33).",
  bluetooth_example2_behavior: "El comportamiento es simple: mientras el botón esté presionado en la app, el LED correspondiente permanecerá encendido. Al soltar el botón, el LED se apaga inmediatamente.",
  bluetooth_example2_usecase: "Esta lógica puede aplicarse para controlar cualquier otro dispositivo: motores, robots, sirenas, relés, etc. Aquí usamos LEDs solo como ejemplo visual y práctico para facilitar el aprendizaje.",
  bluetooth_example2_speed: "Una de las ventajas más impresionantes del BLE es su velocidad de respuesta. La comunicación entre la app y la placa es prácticamente instantánea, lo que permite interacciones en tiempo real sin retrasos visibles.",
  bluetooth_example2_codeinfo: "El programa base sigue siendo el mismo que el del ejemplo anterior, pero ahora añadimos condiciones <code>si</code> para verificar los datos recibidos y controlar los LEDs en base a ellos.",
  bluetooth_example2_logic: "El código verifica si la variable datos contiene el valor correspondiente a los botones presionados en la app:",
  bluetooth_example2_if1: "Si datos = \"!B11\", se enciende el LED azul (pin D2).",
  bluetooth_example2_if2: "Si datos = \"!B19\", se enciende el LED verde (pin D33).",
  bluetooth_example2_else: "Si no se detecta ninguno de estos valores (o si se suelta el botón), los LEDs se apagan.",
  bluetooth_example3_title: "Enviando datos de sensores al gráfico de la app",
  bluetooth_example3_intro: "La app Bluefruit Connect ofrece una función llamada Plotter, que permite visualizar datos en tiempo real en forma de gráfico. Esta función es ideal para monitorear sensores analógicos como temperatura, luminosidad (LDR), humedad y más.",
  bluetooth_example3_utility: "Esta herramienta es muy útil para interpretar el comportamiento de los sensores a lo largo del tiempo. Al ver las variaciones gráficamente, podemos identificar picos, caídas y patrones con mayor claridad que solo observando valores en la consola.",
  bluetooth_example3_goal: "En este ejemplo, usaremos el sensor de luminosidad (LDR) integrado en la placa, conectado al pin D39, para enviar valores vía Bluetooth y visualizarlos en tiempo real en el gráfico.",
  bluetooth_example3_plotter_config_tip: "Al hacer clic en el engranaje azul del bloque “Configurar el visualizador para sensores”, es posible añadir más campos para enviar hasta 3 valores diferentes al gráfico, como temperatura, humedad u otros sensores.",
  bluetooth_example3_plotter_limit: "La app Bluefruit Connect admite hasta 3 gráficos simultáneos, facilitando el análisis de múltiples sensores al mismo tiempo.",
  bluetooth_example3_code_explained: "¿Qué hace este programa?",
  bluetooth_example3_step1: "Inicializa el Bluetooth y configura el visualizador con el nombre del sensor.",
  bluetooth_example3_step2: "Lee continuamente el valor del sensor LDR en el pin D39.",
  bluetooth_example3_step3: "Muestra este valor en la consola y también lo envía al gráfico de la app.",
  bluetooth_example3_step4: "Repite este proceso cada 1 segundo.",
  bluetooth_example3_plotter_title: "Accediendo al gráfico en la app",
  bluetooth_example3_plotter_access: "Después de ejecutar el programa y conectarte al dispositivo, haz clic en la opción Plotter en la app Bluefruit Connect.",
  bluetooth_example3_result_title: "Visualizando los resultados en el gráfico",
  bluetooth_example3_result_info: "En el gráfico, puedes seguir la variación del valor del sensor en tiempo real. La línea se moverá conforme cambie la luminosidad — al cubrir el sensor, el valor disminuye; al iluminarlo, el valor aumenta.",
  bluetooth_example3_plotter_controls: "El visualizador también tiene controles en la parte inferior:",
  bluetooth_example3_autoscroll: "AutoScroll: cuando está activado, el gráfico se desplaza automáticamente a medida que llegan nuevos datos.",
  bluetooth_example3_width: "Width: ajusta el grosor de la línea en el gráfico, útil para resaltar picos o suavizar curvas.",

};
